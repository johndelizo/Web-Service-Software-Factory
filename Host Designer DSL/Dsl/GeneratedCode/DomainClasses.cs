//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDesign = global::Microsoft.VisualStudio.Modeling.Design;
namespace Microsoft.Practices.ServiceFactory.HostDesigner
{
	/// <summary>
	/// DomainClass HostDesignerModel
	/// The root in which all other elements are embedded. Appears as a diagram.
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModel.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModel.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("3cd7ca2b-86c6-4bd5-84ba-c86fd2e467eb")]
	public partial class HostDesignerModel : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// HostDesignerModel domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x3cd7ca2b, 0x86c6, 0x4bd5, 0x84, 0xba, 0xc8, 0x6f, 0xd2, 0xe4, 0x67, 0xeb);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public HostDesignerModel(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public HostDesignerModel(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Namespace domain property code
		
		/// <summary>
		/// Namespace domain property Id.
		/// </summary>
		public static readonly global::System.Guid NamespaceDomainPropertyId = new global::System.Guid(0x418bae6b, 0x54a1, 0x421d, 0x8c, 0x1b, 0xaa, 0x4d, 0x46, 0x78, 0x88, 0xf2);
		
		/// <summary>
		/// Storage for Namespace
		/// </summary>
		private global::System.String namespacePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Namespace domain property.
		/// This value is not used.
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModel/Namespace.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModel/Namespace.Category", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModel/Namespace.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("418bae6b-54a1-421d-8c1b-aa4d467888f2")]
		public global::System.String Namespace
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return namespacePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				NamespacePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the HostDesignerModel.Namespace domain property.
		/// </summary>
		internal sealed partial class NamespacePropertyHandler : DslModeling::DomainPropertyValueHandler<HostDesignerModel, global::System.String>
		{
			private NamespacePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the HostDesignerModel.Namespace domain property value handler.
			/// </summary>
			public static readonly NamespacePropertyHandler Instance = new NamespacePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the HostDesignerModel.Namespace domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return NamespaceDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(HostDesignerModel element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.namespacePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(HostDesignerModel element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.namespacePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region HostApplications opposite domain role accessor
		
		/// <summary>
		/// Gets a list of HostApplications.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasHostApplications.HostDesignerModel
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<HostApplication> HostApplications
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<HostApplication>, HostApplication>(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasHostApplications.HostDesignerModelDomainRoleId);
			}
		}
		#endregion
		#region ClientApplications opposite domain role accessor
		
		/// <summary>
		/// Gets a list of ClientApplications.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasClientApplications.HostDesignerModel
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<ClientApplication> ClientApplications
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<ClientApplication>, ClientApplication>(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasClientApplications.HostDesignerModelDomainRoleId);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication.DomainClassId)) 
				{
					return true;
				}
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication sourceHostApplication1 = sourceElement as global::Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication;
			if (sourceHostApplication1 != null)
			{
				// Create link for path HostDesignerModelHasHostApplications.HostApplications
				this.HostApplications.Add(sourceHostApplication1);

				return;
			}
				
			global::Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication sourceClientApplication2 = sourceElement as global::Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication;
			if (sourceClientApplication2 != null)
			{
				// Create link for path HostDesignerModelHasClientApplications.ClientApplications
				this.ClientApplications.Add(sourceClientApplication2);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication sourceHostApplication1 = sourceElement as global::Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication;
			if (sourceHostApplication1 != null)
			{
				// Delete link for path HostDesignerModelHasHostApplications.HostApplications
				
				foreach (DslModeling::ElementLink link in global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasHostApplications.GetLinks((global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModel)this, sourceHostApplication1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasHostApplications.HostDesignerModelDomainRoleId, global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasHostApplications.HostApplicationDomainRoleId);
				}

				return;
			}
				
			global::Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication sourceClientApplication2 = sourceElement as global::Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication;
			if (sourceClientApplication2 != null)
			{
				// Delete link for path HostDesignerModelHasClientApplications.ClientApplications
				
				foreach (DslModeling::ElementLink link in global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasClientApplications.GetLinks((global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModel)this, sourceClientApplication2))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasClientApplications.HostDesignerModelDomainRoleId, global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasClientApplications.ClientApplicationDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.HostDesigner
{
	/// <summary>
	/// DomainClass HostApplication
	/// Description for Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel))]
	[global::System.CLSCompliant(true)]
	[global::System.Diagnostics.DebuggerDisplay("{GetType().Name,nq} (Name = {namePropertyStorage})")]
	[DslModeling::DomainObjectId("54c43a4c-210e-4b4e-b661-4212ca224983")]
	public partial class HostApplication : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// HostApplication domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x54c43a4c, 0x210e, 0x4b4e, 0xb6, 0x61, 0x42, 0x12, 0xca, 0x22, 0x49, 0x83);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public HostApplication(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public HostApplication(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Name domain property code
		
		/// <summary>
		/// Name domain property Id.
		/// </summary>
		public static readonly global::System.Guid NameDomainPropertyId = new global::System.Guid(0xa7506df5, 0x82da, 0x4ea1, 0x8b, 0x28, 0x77, 0xad, 0xf9, 0x88, 0x27, 0x3f);
		
		/// <summary>
		/// Storage for Name
		/// </summary>
		private global::System.String namePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Name domain property.
		/// An identifier for the host application.
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication/Name.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication/Name.Category", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication/Name.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslModeling::ElementName]
		[DslModeling::DomainObjectId("a7506df5-82da-4ea1-8b28-77adf988273f")]
		public global::System.String Name
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return namePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				NamePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the HostApplication.Name domain property.
		/// </summary>
		internal sealed partial class NamePropertyHandler : DslModeling::DomainPropertyValueHandler<HostApplication, global::System.String>
		{
			private NamePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the HostApplication.Name domain property value handler.
			/// </summary>
			public static readonly NamePropertyHandler Instance = new NamePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the HostApplication.Name domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return NameDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(HostApplication element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.namePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(HostApplication element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.namePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region ImplementationProject domain property code
		
		/// <summary>
		/// ImplementationProject domain property Id.
		/// </summary>
		public static readonly global::System.Guid ImplementationProjectDomainPropertyId = new global::System.Guid(0x93174466, 0x0cba, 0x4b5e, 0xbc, 0xd0, 0x1d, 0xdd, 0xa6, 0xa9, 0x9d, 0x9a);
		
		/// <summary>
		/// Storage for ImplementationProject
		/// </summary>
		private global::System.String implementationProjectPropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of ImplementationProject domain property.
		/// The Visual Studio project that represents the host application.
		/// </summary>
		[System.ComponentModel.Editor(typeof(Microsoft.Practices.VisualStudio.Helper.Design.ProjectsOnlySolutionPickerEditor), typeof(System.Drawing.Design.UITypeEditor))]
		[System.ComponentModel.TypeConverterAttribute(typeof(System.ComponentModel.TypeConverter))]
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication/ImplementationProject.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication/ImplementationProject.Category", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication/ImplementationProject.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("93174466-0cba-4b5e-bcd0-1ddda6a99d9a")]
		public global::System.String ImplementationProject
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return implementationProjectPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				ImplementationProjectPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the HostApplication.ImplementationProject domain property.
		/// </summary>
		internal sealed partial class ImplementationProjectPropertyHandler : DslModeling::DomainPropertyValueHandler<HostApplication, global::System.String>
		{
			private ImplementationProjectPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the HostApplication.ImplementationProject domain property value handler.
			/// </summary>
			public static readonly ImplementationProjectPropertyHandler Instance = new ImplementationProjectPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the HostApplication.ImplementationProject domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return ImplementationProjectDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(HostApplication element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.implementationProjectPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(HostApplication element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.implementationProjectPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region ImplementationTechnology domain property code
		
		/// <summary>
		/// ImplementationTechnology domain property Id.
		/// </summary>
		public static readonly global::System.Guid ImplementationTechnologyDomainPropertyId = new global::System.Guid(0x358f830a, 0x58a9, 0x477b, 0xae, 0x2c, 0xe4, 0x88, 0x3e, 0x6f, 0xfc, 0x25);
		
		/// <summary>
		/// Storage for ImplementationTechnology
		/// </summary>
		private global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider implementationTechnologyPropertyStorage;
		
		/// <summary>
		/// Gets or sets the value of ImplementationTechnology domain property.
		/// Associates a platform technology (for example, ASMX or WCF) with the Visual
		/// Studio host project.
		/// </summary>
		[System.ComponentModel.Editor(typeof(Microsoft.Practices.Modeling.ExtensionProvider.Design.UITypeEditors.ExtensionProviderEditor), typeof(System.Drawing.Design.UITypeEditor))]
		[System.ComponentModel.TypeConverter(typeof(Microsoft.Practices.Modeling.ExtensionProvider.Design.Converters.ExtensionProviderConverter))]
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication/ImplementationTechnology.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication/ImplementationTechnology.Category", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication/ImplementationTechnology.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("358f830a-58a9-477b-ae2c-e4883e6ffc25")]
		public global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider ImplementationTechnology
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return implementationTechnologyPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				ImplementationTechnologyPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the HostApplication.ImplementationTechnology domain property.
		/// </summary>
		internal sealed partial class ImplementationTechnologyPropertyHandler : DslModeling::DomainPropertyValueHandler<HostApplication, global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider>
		{
			private ImplementationTechnologyPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the HostApplication.ImplementationTechnology domain property value handler.
			/// </summary>
			public static readonly ImplementationTechnologyPropertyHandler Instance = new ImplementationTechnologyPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the HostApplication.ImplementationTechnology domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return ImplementationTechnologyDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider GetValue(HostApplication element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.implementationTechnologyPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(HostApplication element, global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.implementationTechnologyPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region HostDesignerModel opposite domain role accessor
		/// <summary>
		/// Gets or sets HostDesignerModel.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasHostApplications.HostApplication
		/// </summary>
		public virtual HostDesignerModel HostDesignerModel
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasHostApplications.HostApplicationDomainRoleId) as HostDesignerModel;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasHostApplications.HostApplicationDomainRoleId, value);
			}
		}
		#endregion
		#region ServiceDescriptions opposite domain role accessor
		
		/// <summary>
		/// Gets a list of ServiceDescriptions.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.HostDesigner.HostApplicationHasServiceDescriptions.HostApplication
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<ServiceDescription> ServiceDescriptions
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<ServiceDescription>, ServiceDescription>(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostApplicationHasServiceDescriptions.HostApplicationDomainRoleId);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescription.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescription sourceServiceDescription1 = sourceElement as global::Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescription;
			if (sourceServiceDescription1 != null)
			{
				// Create link for path HostApplicationHasServiceDescriptions.ServiceDescriptions
				this.ServiceDescriptions.Add(sourceServiceDescription1);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescription sourceServiceDescription1 = sourceElement as global::Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescription;
			if (sourceServiceDescription1 != null)
			{
				// Delete link for path HostApplicationHasServiceDescriptions.ServiceDescriptions
				
				foreach (DslModeling::ElementLink link in global::Microsoft.Practices.ServiceFactory.HostDesigner.HostApplicationHasServiceDescriptions.GetLinks((global::Microsoft.Practices.ServiceFactory.HostDesigner.HostApplication)this, sourceServiceDescription1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostApplicationHasServiceDescriptions.HostApplicationDomainRoleId, global::Microsoft.Practices.ServiceFactory.HostDesigner.HostApplicationHasServiceDescriptions.ServiceDescriptionDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.HostDesigner
{
	/// <summary>
	/// DomainClass ServiceDescription
	/// Description for
	/// Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescription
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescription.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescription.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel))]
	[global::System.CLSCompliant(true)]
	[global::System.Diagnostics.DebuggerDisplay("{GetType().Name,nq} (Name = {namePropertyStorage})")]
	[DslModeling::DomainObjectId("0aa846e0-8237-42f8-9b7f-2c51438fe0b3")]
	public abstract partial class ServiceDescription : ExtensibleModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// ServiceDescription domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x0aa846e0, 0x8237, 0x42f8, 0x9b, 0x7f, 0x2c, 0x51, 0x43, 0x8f, 0xe0, 0xb3);
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		protected ServiceDescription(DslModeling::Partition partition, DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Name domain property code
		
		/// <summary>
		/// Name domain property Id.
		/// </summary>
		public static readonly global::System.Guid NameDomainPropertyId = new global::System.Guid(0x6201b91c, 0x00d3, 0x468b, 0x82, 0xc0, 0x3f, 0x33, 0xd4, 0xb2, 0xb9, 0x08);
		
		/// <summary>
		/// Storage for Name
		/// </summary>
		private global::System.String namePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Name domain property.
		/// The name of the service reference.
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescription/Name.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescription/Name.Category", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescription/Name.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslModeling::ElementName]
		[DslModeling::DomainObjectId("6201b91c-00d3-468b-82c0-3f33d4b2b908")]
		public global::System.String Name
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return namePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				NamePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the ServiceDescription.Name domain property.
		/// </summary>
		internal sealed partial class NamePropertyHandler : DslModeling::DomainPropertyValueHandler<ServiceDescription, global::System.String>
		{
			private NamePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the ServiceDescription.Name domain property value handler.
			/// </summary>
			public static readonly NamePropertyHandler Instance = new NamePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the ServiceDescription.Name domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return NameDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(ServiceDescription element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.namePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(ServiceDescription element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.namePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region HostApplication opposite domain role accessor
		/// <summary>
		/// Gets or sets HostApplication.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.HostDesigner.HostApplicationHasServiceDescriptions.ServiceDescription
		/// </summary>
		public virtual HostApplication HostApplication
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.HostDesigner.HostApplicationHasServiceDescriptions.ServiceDescriptionDomainRoleId) as HostApplication;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.HostDesigner.HostApplicationHasServiceDescriptions.ServiceDescriptionDomainRoleId, value);
			}
		}
		#endregion
		#region Endpoints opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Endpoints.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescriptionHasEndpoints.ServiceDescription
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Endpoint> Endpoints
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Endpoint>, Endpoint>(global::Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescriptionHasEndpoints.ServiceDescriptionDomainRoleId);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Microsoft.Practices.ServiceFactory.HostDesigner.Endpoint.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Microsoft.Practices.ServiceFactory.HostDesigner.Endpoint sourceEndpoint1 = sourceElement as global::Microsoft.Practices.ServiceFactory.HostDesigner.Endpoint;
			if (sourceEndpoint1 != null)
			{
				// Create link for path ServiceDescriptionHasEndpoints.Endpoints
				this.Endpoints.Add(sourceEndpoint1);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Microsoft.Practices.ServiceFactory.HostDesigner.Endpoint sourceEndpoint1 = sourceElement as global::Microsoft.Practices.ServiceFactory.HostDesigner.Endpoint;
			if (sourceEndpoint1 != null)
			{
				// Delete link for path ServiceDescriptionHasEndpoints.Endpoints
				
				foreach (DslModeling::ElementLink link in global::Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescriptionHasEndpoints.GetLinks((global::Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescription)this, sourceEndpoint1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescriptionHasEndpoints.ServiceDescriptionDomainRoleId, global::Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescriptionHasEndpoints.EndpointDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.HostDesigner
{
	/// <summary>
	/// DomainClass ServiceReference
	/// Description for Microsoft.Practices.ServiceFactory.HostDesigner.ServiceReference
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.ServiceReference.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.ServiceReference.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("0acc8cb2-49e9-42e5-9925-e690475224cd")]
	public partial class ServiceReference : ServiceDescription
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// ServiceReference domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x0acc8cb2, 0x49e9, 0x42e5, 0x99, 0x25, 0xe6, 0x90, 0x47, 0x52, 0x24, 0xcd);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public ServiceReference(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public ServiceReference(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region ServiceImplementationType domain property code
		
		/// <summary>
		/// ServiceImplementationType domain property Id.
		/// </summary>
		public static readonly global::System.Guid ServiceImplementationTypeDomainPropertyId = new global::System.Guid(0xc7bfcbe0, 0x4e6f, 0x4118, 0xa9, 0x48, 0x36, 0xe3, 0x44, 0x97, 0x91, 0xbf);
		
		/// <summary>
		/// Storage for ServiceImplementationType
		/// </summary>
		private global::Microsoft.VisualStudio.Modeling.Integration.ModelBusReference serviceImplementationTypePropertyStorage;
		
		/// <summary>
		/// Gets or sets the value of ServiceImplementationType domain property.
		/// A cross-model reference to the associated service on the service contract model.
		/// </summary>
		[System.ComponentModel.Editor(typeof(Microsoft.VisualStudio.Modeling.Integration.Picker.ModelElementReferenceEditor), typeof(System.Drawing.Design.UITypeEditor))]
		[System.ComponentModel.TypeConverter(typeof(Microsoft.VisualStudio.Modeling.Integration.ModelBusReferenceTypeConverter))]
		[Microsoft.VisualStudio.Modeling.Integration.Picker.SupplyFileBasedBrowserConfiguration("Please choose a ServiceContract file",  "Service Contract files|*.servicecontract")]
		[Microsoft.VisualStudio.Modeling.Integration.Picker.ApplyElementTypeLimitations(typeof(Microsoft.Practices.ServiceFactory.ServiceContracts.Service))]
		[System.CLSCompliant(false)]
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.ServiceReference/ServiceImplementationType.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.HostDesigner.ServiceReference/ServiceImplementationType.Category", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.ServiceReference/ServiceImplementationType.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("c7bfcbe0-4e6f-4118-a948-36e3449791bf")]
		public global::Microsoft.VisualStudio.Modeling.Integration.ModelBusReference ServiceImplementationType
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return serviceImplementationTypePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				ServiceImplementationTypePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the ServiceReference.ServiceImplementationType domain property.
		/// </summary>
		internal sealed partial class ServiceImplementationTypePropertyHandler : DslModeling::DomainPropertyValueHandler<ServiceReference, global::Microsoft.VisualStudio.Modeling.Integration.ModelBusReference>
		{
			private ServiceImplementationTypePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the ServiceReference.ServiceImplementationType domain property value handler.
			/// </summary>
			public static readonly ServiceImplementationTypePropertyHandler Instance = new ServiceImplementationTypePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the ServiceReference.ServiceImplementationType domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return ServiceImplementationTypeDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::Microsoft.VisualStudio.Modeling.Integration.ModelBusReference GetValue(ServiceReference element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.serviceImplementationTypePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(ServiceReference element, global::Microsoft.VisualStudio.Modeling.Integration.ModelBusReference newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::Microsoft.VisualStudio.Modeling.Integration.ModelBusReference oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.serviceImplementationTypePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.HostDesigner
{
	/// <summary>
	/// DomainClass Endpoint
	/// Description for Microsoft.Practices.ServiceFactory.HostDesigner.Endpoint
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.Endpoint.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.Endpoint.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel))]
	[global::System.CLSCompliant(true)]
	[global::System.Diagnostics.DebuggerDisplay("{GetType().Name,nq} (Name = {namePropertyStorage})")]
	[DslModeling::DomainObjectId("8be985a0-32af-4875-afca-1118e1bc483b")]
	public partial class Endpoint : ExtensibleModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// Endpoint domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x8be985a0, 0x32af, 0x4875, 0xaf, 0xca, 0x11, 0x18, 0xe1, 0xbc, 0x48, 0x3b);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Endpoint(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Endpoint(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Address domain property code
		
		/// <summary>
		/// Address domain property Id.
		/// </summary>
		public static readonly global::System.Guid AddressDomainPropertyId = new global::System.Guid(0x56629039, 0x721c, 0x4137, 0xa6, 0x70, 0x78, 0x64, 0xe6, 0x60, 0x28, 0x17);
		
		/// <summary>
		/// Storage for Address
		/// </summary>
		private global::System.String addressPropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Address domain property.
		/// When used, this string value will be appended to the end of the address. This is
		/// useful when a service has more than one endpoint and each must have different
		/// bindings. 
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.Endpoint/Address.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.HostDesigner.Endpoint/Address.Category", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.Endpoint/Address.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("56629039-721c-4137-a670-7864e6602817")]
		public global::System.String Address
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return addressPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				AddressPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the Endpoint.Address domain property.
		/// </summary>
		internal sealed partial class AddressPropertyHandler : DslModeling::DomainPropertyValueHandler<Endpoint, global::System.String>
		{
			private AddressPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the Endpoint.Address domain property value handler.
			/// </summary>
			public static readonly AddressPropertyHandler Instance = new AddressPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the Endpoint.Address domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return AddressDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(Endpoint element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.addressPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(Endpoint element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.addressPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region Name domain property code
		
		/// <summary>
		/// Name domain property Id.
		/// </summary>
		public static readonly global::System.Guid NameDomainPropertyId = new global::System.Guid(0x763763ca, 0x3dfb, 0x4ffd, 0xa1, 0xa6, 0xf4, 0xa8, 0xcc, 0x6a, 0x66, 0xff);
		
		/// <summary>
		/// Storage for Name
		/// </summary>
		private global::System.String namePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Name domain property.
		/// The name of the endpoint.
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.Endpoint/Name.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.HostDesigner.Endpoint/Name.Category", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.Endpoint/Name.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslModeling::ElementName]
		[DslModeling::DomainObjectId("763763ca-3dfb-4ffd-a1a6-f4a8cc6a66ff")]
		public global::System.String Name
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return namePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				NamePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the Endpoint.Name domain property.
		/// </summary>
		internal sealed partial class NamePropertyHandler : DslModeling::DomainPropertyValueHandler<Endpoint, global::System.String>
		{
			private NamePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the Endpoint.Name domain property value handler.
			/// </summary>
			public static readonly NamePropertyHandler Instance = new NamePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the Endpoint.Name domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return NameDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(Endpoint element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.namePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(Endpoint element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.namePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region ServiceDescription opposite domain role accessor
		/// <summary>
		/// Gets or sets ServiceDescription.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescriptionHasEndpoints.Endpoint
		/// </summary>
		public virtual ServiceDescription ServiceDescription
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescriptionHasEndpoints.EndpointDomainRoleId) as ServiceDescription;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.HostDesigner.ServiceDescriptionHasEndpoints.EndpointDomainRoleId, value);
			}
		}
		#endregion
		#region Proxies opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Proxies.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.HostDesigner.ProxyReferencesEndpoint.Endpoint
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Proxy> Proxies
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Proxy>, Proxy>(global::Microsoft.Practices.ServiceFactory.HostDesigner.ProxyReferencesEndpoint.EndpointDomainRoleId);
			}
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.HostDesigner
{
	/// <summary>
	/// DomainClass ClientApplication
	/// Description for
	/// Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel))]
	[global::System.CLSCompliant(true)]
	[global::System.Diagnostics.DebuggerDisplay("{GetType().Name,nq} (Name = {namePropertyStorage})")]
	[DslModeling::DomainObjectId("f1d19513-829d-44c4-b97a-66d7da96fa2a")]
	public partial class ClientApplication : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// ClientApplication domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0xf1d19513, 0x829d, 0x44c4, 0xb9, 0x7a, 0x66, 0xd7, 0xda, 0x96, 0xfa, 0x2a);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public ClientApplication(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public ClientApplication(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Name domain property code
		
		/// <summary>
		/// Name domain property Id.
		/// </summary>
		public static readonly global::System.Guid NameDomainPropertyId = new global::System.Guid(0xac86f887, 0xb41c, 0x4747, 0xbc, 0xea, 0xfe, 0x36, 0xf1, 0x6a, 0x4d, 0x52);
		
		/// <summary>
		/// Storage for Name
		/// </summary>
		private global::System.String namePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Name domain property.
		/// An identifier for the client application.
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication/Name.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication/Name.Category", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication/Name.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslModeling::ElementName]
		[DslModeling::DomainObjectId("ac86f887-b41c-4747-bcea-fe36f16a4d52")]
		public global::System.String Name
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return namePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				NamePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the ClientApplication.Name domain property.
		/// </summary>
		internal sealed partial class NamePropertyHandler : DslModeling::DomainPropertyValueHandler<ClientApplication, global::System.String>
		{
			private NamePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the ClientApplication.Name domain property value handler.
			/// </summary>
			public static readonly NamePropertyHandler Instance = new NamePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the ClientApplication.Name domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return NameDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(ClientApplication element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.namePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(ClientApplication element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.namePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region ImplementationTechnology domain property code
		
		/// <summary>
		/// ImplementationTechnology domain property Id.
		/// </summary>
		public static readonly global::System.Guid ImplementationTechnologyDomainPropertyId = new global::System.Guid(0x1788f448, 0x5ac1, 0x4568, 0xa6, 0x81, 0x03, 0x38, 0xd5, 0x68, 0x40, 0x1d);
		
		/// <summary>
		/// Storage for ImplementationTechnology
		/// </summary>
		private global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider implementationTechnologyPropertyStorage;
		
		/// <summary>
		/// Gets or sets the value of ImplementationTechnology domain property.
		/// Associates a platform technology (for example, ASMX or WCF) with the Visual
		/// Studio client project.
		/// </summary>
		[System.ComponentModel.Editor(typeof(Microsoft.Practices.Modeling.ExtensionProvider.Design.UITypeEditors.ExtensionProviderEditor), typeof(System.Drawing.Design.UITypeEditor))]
		[System.ComponentModel.TypeConverter(typeof(Microsoft.Practices.Modeling.ExtensionProvider.Design.Converters.ExtensionProviderConverter))]
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication/ImplementationTechnology.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication/ImplementationTechnology.Category", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication/ImplementationTechnology.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("1788f448-5ac1-4568-a681-0338d568401d")]
		public global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider ImplementationTechnology
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return implementationTechnologyPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				ImplementationTechnologyPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the ClientApplication.ImplementationTechnology domain property.
		/// </summary>
		internal sealed partial class ImplementationTechnologyPropertyHandler : DslModeling::DomainPropertyValueHandler<ClientApplication, global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider>
		{
			private ImplementationTechnologyPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the ClientApplication.ImplementationTechnology domain property value handler.
			/// </summary>
			public static readonly ImplementationTechnologyPropertyHandler Instance = new ImplementationTechnologyPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the ClientApplication.ImplementationTechnology domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return ImplementationTechnologyDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider GetValue(ClientApplication element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.implementationTechnologyPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(ClientApplication element, global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.implementationTechnologyPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region ImplementationProject domain property code
		
		/// <summary>
		/// ImplementationProject domain property Id.
		/// </summary>
		public static readonly global::System.Guid ImplementationProjectDomainPropertyId = new global::System.Guid(0x47ae3232, 0x25b1, 0x4ad4, 0x9b, 0xff, 0x52, 0xe3, 0xe9, 0x84, 0x20, 0x18);
		
		/// <summary>
		/// Storage for ImplementationProject
		/// </summary>
		private global::System.String implementationProjectPropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of ImplementationProject domain property.
		/// The Visual Studio project that represents the host application.
		/// </summary>
		[System.ComponentModel.Editor(typeof(Microsoft.Practices.VisualStudio.Helper.Design.ProjectsOnlySolutionPickerEditor), typeof(System.Drawing.Design.UITypeEditor))]
		[System.ComponentModel.TypeConverterAttribute(typeof(System.ComponentModel.TypeConverter))]
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication/ImplementationProject.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication/ImplementationProject.Category", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication/ImplementationProject.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("47ae3232-25b1-4ad4-9bff-52e3e9842018")]
		public global::System.String ImplementationProject
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return implementationProjectPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				ImplementationProjectPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the ClientApplication.ImplementationProject domain property.
		/// </summary>
		internal sealed partial class ImplementationProjectPropertyHandler : DslModeling::DomainPropertyValueHandler<ClientApplication, global::System.String>
		{
			private ImplementationProjectPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the ClientApplication.ImplementationProject domain property value handler.
			/// </summary>
			public static readonly ImplementationProjectPropertyHandler Instance = new ImplementationProjectPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the ClientApplication.ImplementationProject domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return ImplementationProjectDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(ClientApplication element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.implementationProjectPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(ClientApplication element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.implementationProjectPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region Proxies opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Proxies.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplicationHasProxies.ClientApplication
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Proxy> Proxies
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Proxy>, Proxy>(global::Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplicationHasProxies.ClientApplicationDomainRoleId);
			}
		}
		#endregion
		#region HostDesignerModel opposite domain role accessor
		/// <summary>
		/// Gets or sets HostDesignerModel.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasClientApplications.ClientApplication
		/// </summary>
		public virtual HostDesignerModel HostDesignerModel
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasClientApplications.ClientApplicationDomainRoleId) as HostDesignerModel;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModelHasClientApplications.ClientApplicationDomainRoleId, value);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Microsoft.Practices.ServiceFactory.HostDesigner.Proxy.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Microsoft.Practices.ServiceFactory.HostDesigner.Proxy sourceProxy1 = sourceElement as global::Microsoft.Practices.ServiceFactory.HostDesigner.Proxy;
			if (sourceProxy1 != null)
			{
				// Create link for path ClientApplicationHasProxies.Proxies
				this.Proxies.Add(sourceProxy1);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Microsoft.Practices.ServiceFactory.HostDesigner.Proxy sourceProxy1 = sourceElement as global::Microsoft.Practices.ServiceFactory.HostDesigner.Proxy;
			if (sourceProxy1 != null)
			{
				// Delete link for path ClientApplicationHasProxies.Proxies
				
				foreach (DslModeling::ElementLink link in global::Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplicationHasProxies.GetLinks((global::Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplication)this, sourceProxy1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplicationHasProxies.ClientApplicationDomainRoleId, global::Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplicationHasProxies.ProxyDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.HostDesigner
{
	/// <summary>
	/// DomainClass Proxy
	/// Description for Microsoft.Practices.ServiceFactory.HostDesigner.Proxy
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.Proxy.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.Proxy.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel))]
	[global::System.CLSCompliant(true)]
	[global::System.Diagnostics.DebuggerDisplay("{GetType().Name,nq} (Name = {namePropertyStorage})")]
	[DslModeling::DomainObjectId("e2f24ffd-9f89-4e5c-aa64-2f16c4839482")]
	public partial class Proxy : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// Proxy domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0xe2f24ffd, 0x9f89, 0x4e5c, 0xaa, 0x64, 0x2f, 0x16, 0xc4, 0x83, 0x94, 0x82);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Proxy(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Proxy(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Name domain property code
		
		/// <summary>
		/// Name domain property Id.
		/// </summary>
		public static readonly global::System.Guid NameDomainPropertyId = new global::System.Guid(0xc1a544f6, 0x07cb, 0x45d4, 0xa9, 0x29, 0xa2, 0x90, 0x1e, 0xbb, 0xc1, 0xb2);
		
		/// <summary>
		/// Storage for Name
		/// </summary>
		private global::System.String namePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Name domain property.
		/// The name of the proxy.
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.Proxy/Name.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.HostDesigner.Proxy/Name.Category", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.Proxy/Name.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslModeling::ElementName]
		[DslModeling::DomainObjectId("c1a544f6-07cb-45d4-a929-a2901ebbc1b2")]
		public global::System.String Name
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return namePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				NamePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the Proxy.Name domain property.
		/// </summary>
		internal sealed partial class NamePropertyHandler : DslModeling::DomainPropertyValueHandler<Proxy, global::System.String>
		{
			private NamePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the Proxy.Name domain property value handler.
			/// </summary>
			public static readonly NamePropertyHandler Instance = new NamePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the Proxy.Name domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return NameDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(Proxy element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.namePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(Proxy element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.namePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region ClientApplication opposite domain role accessor
		/// <summary>
		/// Gets or sets ClientApplication.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplicationHasProxies.Proxy
		/// </summary>
		public virtual ClientApplication ClientApplication
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplicationHasProxies.ProxyDomainRoleId) as ClientApplication;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.HostDesigner.ClientApplicationHasProxies.ProxyDomainRoleId, value);
			}
		}
		#endregion
		#region Endpoint opposite domain role accessor
		/// <summary>
		/// Gets or sets Endpoint.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.HostDesigner.ProxyReferencesEndpoint.Proxy
		/// </summary>
		public virtual Endpoint Endpoint
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.HostDesigner.ProxyReferencesEndpoint.ProxyDomainRoleId) as Endpoint;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.HostDesigner.ProxyReferencesEndpoint.ProxyDomainRoleId, value);
			}
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.HostDesigner
{
	/// <summary>
	/// DomainClass ExtensibleModelElement
	/// Description for
	/// Microsoft.Practices.ServiceFactory.HostDesigner.ExtensibleModelElement
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.ExtensibleModelElement.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.ExtensibleModelElement.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("1cfa548e-da98-49d9-a1d5-89002775439b")]
	public abstract partial class ExtensibleModelElement : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// ExtensibleModelElement domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x1cfa548e, 0xda98, 0x49d9, 0xa1, 0xd5, 0x89, 0x00, 0x27, 0x75, 0x43, 0x9b);
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		protected ExtensibleModelElement(DslModeling::Partition partition, DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region ObjectExtenderContainer domain property code
		
		/// <summary>
		/// ObjectExtenderContainer domain property Id.
		/// </summary>
		public static readonly global::System.Guid ObjectExtenderContainerDomainPropertyId = new global::System.Guid(0x77298aa0, 0xe17b, 0x4a89, 0xa9, 0x78, 0xd3, 0x67, 0x15, 0x81, 0x2a, 0xc6);
		
		/// <summary>
		/// Storage for ObjectExtenderContainer
		/// </summary>
		private global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.ObjectExtenderContainer objectExtenderContainerPropertyStorage;
		
		/// <summary>
		/// Gets or sets the value of ObjectExtenderContainer domain property.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.HostDesigner.ExtensibleModelElement.Object
		/// Extender Container
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.HostDesigner.ExtensibleModelElement/ObjectExtenderContainer.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.HostDesigner.ExtensibleModelElement/ObjectExtenderContainer.Category", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.HostDesigner.ExtensibleModelElement/ObjectExtenderContainer.Description", typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel), "Microsoft.Practices.ServiceFactory.HostDesigner.GeneratedCode.DomainModelResx")]
		[global::System.ComponentModel.Browsable(false)]
		[DslModeling::DomainObjectId("77298aa0-e17b-4a89-a978-d36715812ac6")]
		public global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.ObjectExtenderContainer ObjectExtenderContainer
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return objectExtenderContainerPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				ObjectExtenderContainerPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the ExtensibleModelElement.ObjectExtenderContainer domain property.
		/// </summary>
		internal sealed partial class ObjectExtenderContainerPropertyHandler : DslModeling::DomainPropertyValueHandler<ExtensibleModelElement, global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.ObjectExtenderContainer>
		{
			private ObjectExtenderContainerPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the ExtensibleModelElement.ObjectExtenderContainer domain property value handler.
			/// </summary>
			public static readonly ObjectExtenderContainerPropertyHandler Instance = new ObjectExtenderContainerPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the ExtensibleModelElement.ObjectExtenderContainer domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return ObjectExtenderContainerDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.ObjectExtenderContainer GetValue(ExtensibleModelElement element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.objectExtenderContainerPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(ExtensibleModelElement element, global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.ObjectExtenderContainer newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.ObjectExtenderContainer oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.objectExtenderContainerPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
	}
}
