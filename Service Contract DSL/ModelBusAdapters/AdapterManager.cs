//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System.Linq;
using Mef = global::System.ComponentModel.Composition;
using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslIntegration = global::Microsoft.VisualStudio.Modeling.Integration;
using DslIntegrationShell = Microsoft.VisualStudio.Modeling.Integration.Shell;

namespace Microsoft.Practices.ServiceFactory.ServiceContracts.ModelBusAdapters
{
	/// <summary>
	/// Adapter manager base class (double derived pattern) for the ServiceContractDsl Designer
	/// </summary>
    public partial class ServiceContractDslAdapterManagerBase : DslIntegrationShell::VsModelingAdapterManager
	{
		#region Fields
        /// <summary>
        /// A list of the adapter ids supported by this adapter manager
        /// </summary>
        private string[] supportedAdapterIds;

        /// <summary>
        /// A list of the element types exposed by the adapter
        /// </summary>
        private global::System.Collections.ObjectModel.ReadOnlyCollection<DslIntegration::SupportedType> exposedElementTypes;
		#endregion


		#region Constructor(s)
        public ServiceContractDslAdapterManagerBase()
		{
		}
		#endregion

        /// <summary>
        /// returns the list of Ids of Modelbus adapterss supporter by this ModelBusAdapter manager
        /// </summary>
        public override global::System.Collections.Generic.IEnumerable<string> GetSupportedLogicalAdapterIds()
		{
            if (supportedAdapterIds == null)
            {
                //Initialize AdapterIds understood by this AdapterManager
                supportedAdapterIds = new string[] { ServiceContractDslAdapter.AdapterId };
            }
            return supportedAdapterIds;
		}

        /// <summary>
        /// Instantiates a ModelBusAdapter for the ServiceContractDsl model of given ModelBusReference and Root Model element
        /// </summary>
        /// <param name="reference">ModelBusReference of the model</param>
        /// <param name="rootModelElement">Root element of the model</param>
        /// <returns>A newly created ModelBusAdapter to manipulate the DSL</returns>
        protected override DslIntegration::ModelingAdapter CreateModelingAdapterInstance(DslIntegration::ModelBusReference reference, DslModeling::ModelElement rootModelElement)
		{
            if (rootModelElement as global::Microsoft.Practices.ServiceFactory.ServiceContracts.ServiceContractModel == null) throw new global::System.ArgumentException("Invalid model root passed");
            return new ServiceContractDslAdapter(reference, this, rootModelElement as global::Microsoft.Practices.ServiceFactory.ServiceContracts.ServiceContractModel);
		}

        /// <summary>
        /// Returns an enumeration of all the Types supported by a given Adapter.
        /// </summary>
        /// <param name="adapterId">Id of the adapter</param>
        /// <returns>Supported types by the Adapter</returns>
        public override global::System.Collections.Generic.IEnumerable<DslIntegration::SupportedType> GetExposedElementTypes(string adapterId)
		{
            // Do we support this type of adapter?
            if (!this.GetSupportedLogicalAdapterIds().Contains(adapterId))
			{
                return new DslIntegration::SupportedType[] { };
			}

            // Cache management
            if (exposedElementTypes == null)
            {
				global::System.Collections.Generic.List<DslIntegration::SupportedType> types = new global::System.Collections.Generic.List<DslIntegration::SupportedType>();
			
                types.Add(
                    new DslIntegration::SupportedType(typeof(ServiceContractModel), "ServiceContractModel"));
			
                types.Add(
                    new DslIntegration::SupportedType(typeof(ServiceContract), "ServiceContract"));
			
                types.Add(
                    new DslIntegration::SupportedType(typeof(Operation), "Operation"));
			
                types.Add(
                    new DslIntegration::SupportedType(typeof(Service), "Service"));
			
                types.Add(
                    new DslIntegration::SupportedType(typeof(Message), "Message"));
			
                types.Add(
                    new DslIntegration::SupportedType(typeof(DataContractMessagePart), "DataContractMessagePart"));
			
                types.Add(
                    new DslIntegration::SupportedType(typeof(PrimitiveMessagePart), "PrimitiveMessagePart"));
			
                types.Add(
                    new DslIntegration::SupportedType(typeof(XsdMessage), "XsdMessage"));
			
                types.Add(
                    new DslIntegration::SupportedType(typeof(DataContractFault), "DataContractFault"));
			
                types.Add(
                    new DslIntegration::SupportedType(typeof(XsdElementFault), "XsdElementFault"));
 				exposedElementTypes = types.AsReadOnly();
           }

            return exposedElementTypes;
        }

        /// <summary>
        /// Can this adapter manager create a reference on a model described by the parameters?
        /// </summary>
        /// <param name="modelLocatorInfo">The default implementation (which can be overriden) 
        /// supports models described as ProjectItems, and
        /// model file path whether or not in the project/solution</param>
        /// <returns>true if this adapter manager knowshow to create a reference on the model, and flefalsase otherzise</returns>
        public override bool CanCreateReference(params object[] modelLocatorInfo)
        {
            // Only interested in project items or Path
            global::EnvDTE.ProjectItem item = GetProjectItem(modelLocatorInfo);
           
            return (item != null);
        }


        /// <summary>
        /// Create a reference on a model described by the parameters
        /// </summary>
        /// <param name="modelLocatorInfo">The default implementation (which can be overriden) 
        /// supports models described as ProjectItems, and
        /// model file path whether or not in the project/solution</param>
        /// <returns>true if this adapter </returns>
        public override DslIntegration::ModelBusReference CreateReference(params object[] modelLocatorInfo)
        {
            // Infer the project item from the parameters
            global::EnvDTE.ProjectItem item = GetProjectItem(modelLocatorInfo);

            if (item == null)
            {
                return null;
            }

            // Create the part of the reference which depends on the Adapter
            DslIntegration::ModelingAdapterReference mar = new DslIntegration::ModelingAdapterReference(null, null, item.get_FileNames(1));

            // And aggregate it with the adapter manager's part
            DslIntegration::ModelBusReference mbr = new DslIntegration::ModelBusReference(
                this.ModelBus, ServiceContractDslAdapter.AdapterId,
                global::System.IO.Path.GetFileNameWithoutExtension(item.Name),
                mar);

            return mbr;
        }
		
		
		#region Private methods
       /// <summary>
        /// If a reference can be created from this locator info, then the corresponding
        /// project item will be returned.
        /// </summary>
        private global::EnvDTE.ProjectItem GetProjectItem(params object[] modelLocatorInfo)
        {
            if (modelLocatorInfo == null || modelLocatorInfo.Length == 0)
            {
                return null;
            }

            // Only interested in project items
            foreach (object item in modelLocatorInfo)
            {
                // Simple case where the argument is directly a ProjectItem
                global::EnvDTE.ProjectItem projectItem = item as global::EnvDTE.ProjectItem;

                // Case where this is a pathname (whether in the solution of not)
				if (projectItem == null && item is string)
				{
					global::EnvDTE.DTE dte = this.ModelBus.GetService(typeof(global::EnvDTE.DTE)) as global::EnvDTE.DTE;
					if (dte == null)
						dte = Microsoft.VisualStudio.Shell.Package.GetGlobalService(typeof(global::EnvDTE.DTE)) as global::EnvDTE.DTE;
					if (dte == null)
						return null;
					
					projectItem = dte.Solution.FindProjectItem((string)item);
					if (projectItem == null)
					{
                        //Item is not in the solution. Add existing item to this current project.
						projectItem = dte.ItemOperations.AddExistingItem((string)item);
					}
				}

                // We only support project items concening models of the right file extension
				if (projectItem != null && !string.IsNullOrEmpty(projectItem.Name))
				{
                    global::System.IO.FileInfo fi = new global::System.IO.FileInfo(projectItem.Name);
                    if (string.CompareOrdinal(this.FileExtension, fi.Extension) == 0)
                    {
                        return projectItem;
                    }
                }
            }

            return null;
        }
		
		/// <summary>
        /// File extension of the managed model
        /// </summary>
        protected string FileExtension
        {
            get
            {
                return ".servicecontract";
            }
		}

		#endregion
	}

	/// <summary>
	/// ModelBus modeling adapter manager for a ServiceContractDslAdapter model adapter
	/// </summary>
	[Mef::Export(typeof(DslIntegration::ModelBusAdapterManager))]
	[Mef::ExportMetadata(DslIntegration::CompositionAttributes.AdapterIdKey,ServiceContractDslAdapter.AdapterId)]
	// Used to be in Beta1[DslIntegration.HandlesAdapter(StateMachineAdapter.AdapterId)]
	[DslIntegration::HostSpecific(DslIntegrationShell::VsModelingAdapterManager.HostName)]
	// [DslIntegration::HostSpecific("T4VSHost")] - This adapter manager is not capable of running in AppDomain 1
	public partial class ServiceContractDslAdapterManager : ServiceContractDslAdapterManagerBase
    {
    }
}
