//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using DslIntegration = global::Microsoft.VisualStudio.Modeling.Integration;

namespace Microsoft.Practices.ServiceFactory.ServiceContracts.ModelBusAdapters
{
    /// <summary>
    /// ModelBus modeling adapter manager for a ServiceContractDsl  model helper methods
    /// </summary>
	public partial class ServiceContractDslAdapterManager
    {
        #region Helper methods

        /// <summary>
        /// Create a new ServiceContractDsl model and return a modelbus reference to it
        /// </summary>
        /// <param name="modelName">Name of the model to create (with or without the extension)</param>
        /// <param name="relativeTo">ModelBusRefrence on a model relative to which to create the new model</param>
        /// <param name="relativePath">Path relative to the <paramref name="relativeTo"/> model. If <c>null</c>, the new
        /// model is created at the same location as the <paramref name="relativeTo"/> model</param>
        public static DslIntegration::ModelBusReference CreateServiceContractModel(string modelName, DslIntegration::ModelBusReference relativeTo, string relativePath = null)
        {
            DslIntegration::ModelingAdapter adapter = relativeTo.ModelBus.CreateAdapter(relativeTo) as DslIntegration::ModelingAdapter;
            if (adapter != null)
            {
                string filename = adapter.DocumentHandler.ModelFile;
                return CreateServiceContractModel(modelName, filename, relativePath);
            }
            else
                return null;
        }



        /// <summary>
        /// Create a new ServiceContractDsl model and return a modelbus reference to it
        /// </summary>
        /// <param name="modelName">Name of the model to create (with or without the extension)</param>
        /// <param name="relativeToPathName">pathName on a model relative to which to create the new model</param>
        /// <param name="relativePath">Path relative to the <paramref name="relativeTo"/> model. If <c>null</c>, the new
        /// model is created at the same location as the <paramref name="relativeTo"/> model</param>
        public static DslIntegration::ModelBusReference CreateServiceContractModel(string modelName, string relativeToPathName, string relativePath = null)
        {
            global::EnvDTE.DTE dte = Microsoft.VisualStudio.Shell.Package.GetGlobalService(typeof(global::EnvDTE.DTE)) as global::EnvDTE.DTE;
            DslIntegration::IModelBus modelBus = Microsoft.VisualStudio.Shell.Package.GetGlobalService(typeof(DslIntegration::SModelBus)) as DslIntegration::IModelBus;
            global::EnvDTE.ProjectItem item = dte.Solution.FindProjectItem(relativeToPathName);
            global::EnvDTE.Project project = item.ContainingProject;

            string template = (dte.Solution as global::EnvDTE80.Solution2).GetProjectItemTemplate("ServiceContractDsl.zip", "CSharp");
        
            string modelNameWithExtension = global::System.IO.Path.ChangeExtension(modelName, ".servicecontract");
            global::EnvDTE.ProjectItem newItem = project.ProjectItems.AddFromTemplate(template, modelNameWithExtension);
            if (newItem == null) /// Well known bug
                newItem = project.ProjectItems.Item(modelNameWithExtension);

            DslIntegration::ModelingAdapterReference mar = new DslIntegration::ModelingAdapterReference(null, null, newItem.get_FileNames(1));

            DslIntegration::ModelBusReference mbr = new DslIntegration::ModelBusReference(modelBus,
                                                          ServiceContractDslAdapter.AdapterId,
                                                          System.IO.Path.GetFileNameWithoutExtension(newItem.Name),
                                                          mar);

            return mbr; 
        }

        /// <summary>
        /// If a reference can be created from this locator info, then the corresponding
        /// project item will be returned.
        /// </summary>
        private global::EnvDTE.ProjectItem GetProjectItem(params object[] modelLocatorInfo)
        {
            if (modelLocatorInfo == null || modelLocatorInfo.Length == 0)
            {
                return null;
            }

            // Only interested in project items
            foreach (object item in modelLocatorInfo)
            {
                // Simple case where the argument is directly a ProjectItem
                global::EnvDTE.ProjectItem projectItem = item as global::EnvDTE.ProjectItem;

                // Case where this is a pathname (whether in the solution of not)
				if (projectItem == null && item is string)
				{
					global::EnvDTE.DTE dte = this.ModelBus.GetService(typeof(global::EnvDTE.DTE)) as global::EnvDTE.DTE;
					if (dte == null)
						dte = Microsoft.VisualStudio.Shell.Package.GetGlobalService(typeof(global::EnvDTE.DTE)) as global::EnvDTE.DTE;
					if (dte == null)
						return null;
					
					projectItem = dte.Solution.FindProjectItem((string)item);
					if (projectItem == null)
					{
                        //Item is not in the solution. Add existing item to this current project.
						projectItem = dte.ItemOperations.AddExistingItem((string)item);
					}
				}

                // We only support project items concening models of the right file extension
				if (projectItem != null && !string.IsNullOrEmpty(projectItem.Name))
				{
                    global::System.IO.FileInfo fi = new global::System.IO.FileInfo(projectItem.Name);
                    if (string.CompareOrdinal(this.FileExtension, fi.Extension) == 0)
                    {
                        return projectItem;
                    }
                }
            }

            return null;
        }
		#endregion	
    }
}
