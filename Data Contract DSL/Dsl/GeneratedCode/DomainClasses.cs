//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDesign = global::Microsoft.VisualStudio.Modeling.Design;
namespace Microsoft.Practices.ServiceFactory.DataContracts
{
	/// <summary>
	/// DomainClass DataContractModel
	/// The root in which all other elements are embedded. Appears as a diagram.
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel))]
	[global::System.CLSCompliant(true)]
	[global::System.Diagnostics.DebuggerDisplay("{GetType().Name,nq} (Name = {namePropertyStorage})")]
	[DslModeling::DomainObjectId("5200c72f-45bf-45e7-adef-3fab8302f9ba")]
	public partial class DataContractModel : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// DataContractModel domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x5200c72f, 0x45bf, 0x45e7, 0xad, 0xef, 0x3f, 0xab, 0x83, 0x02, 0xf9, 0xba);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public DataContractModel(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public DataContractModel(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region ImplementationTechnology domain property code
		
		/// <summary>
		/// ImplementationTechnology domain property Id.
		/// </summary>
		public static readonly global::System.Guid ImplementationTechnologyDomainPropertyId = new global::System.Guid(0xe9f1452b, 0x1136, 0x4702, 0x91, 0x71, 0xbe, 0x75, 0xe6, 0x59, 0x07, 0x01);
		
		/// <summary>
		/// Storage for ImplementationTechnology
		/// </summary>
		private global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider implementationTechnologyPropertyStorage;
		
		/// <summary>
		/// Gets or sets the value of ImplementationTechnology domain property.
		/// This associates a platform technology with each of the shapes on the design
		/// surface. As a result, each shape may acquire additional properties specific for
		/// the chosen technology.
		/// </summary>
		[System.ComponentModel.Editor(typeof(Microsoft.Practices.Modeling.ExtensionProvider.Design.UITypeEditors.ExtensionProviderEditor),typeof(System.Drawing.Design.UITypeEditor))]
		[System.ComponentModel.TypeConverter(typeof(Microsoft.Practices.Modeling.ExtensionProvider.Design.Converters.ExtensionProviderConverter))]
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel/ImplementationTechnology.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel/ImplementationTechnology.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel/ImplementationTechnology.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("e9f1452b-1136-4702-9171-be75e6590701")]
		public global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider ImplementationTechnology
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return implementationTechnologyPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				ImplementationTechnologyPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the DataContractModel.ImplementationTechnology domain property.
		/// </summary>
		internal sealed partial class ImplementationTechnologyPropertyHandler : DslModeling::DomainPropertyValueHandler<DataContractModel, global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider>
		{
			private ImplementationTechnologyPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the DataContractModel.ImplementationTechnology domain property value handler.
			/// </summary>
			public static readonly ImplementationTechnologyPropertyHandler Instance = new ImplementationTechnologyPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the DataContractModel.ImplementationTechnology domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return ImplementationTechnologyDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider GetValue(DataContractModel element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.implementationTechnologyPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(DataContractModel element, global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.IExtensionProvider oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.implementationTechnologyPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region ProjectMappingTable domain property code
		
		/// <summary>
		/// ProjectMappingTable domain property Id.
		/// </summary>
		public static readonly global::System.Guid ProjectMappingTableDomainPropertyId = new global::System.Guid(0x799673b2, 0x9e6f, 0x4951, 0xae, 0xfd, 0x4b, 0x62, 0xf0, 0xc9, 0xb5, 0x62);
		
		/// <summary>
		/// Storage for ProjectMappingTable
		/// </summary>
		private global::System.String projectMappingTablePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of ProjectMappingTable domain property.
		/// The named entries in the ProjectMapping.xml file. A new entry is created each
		/// time you create an implementation project structure. The Project Mapping Table
		/// entry associates shapes on the design surface with the projects that will
		/// contain the code for those shapes.
		/// </summary>
		[System.ComponentModel.TypeConverter(typeof(Microsoft.Practices.ServiceFactory.RecipeFramework.Extensions.ProjectMapping.Design.ProjectMappingTableConverter))]
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel/ProjectMappingTable.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel/ProjectMappingTable.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel/ProjectMappingTable.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("799673b2-9e6f-4951-aefd-4b62f0c9b562")]
		public global::System.String ProjectMappingTable
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return projectMappingTablePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				ProjectMappingTablePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the DataContractModel.ProjectMappingTable domain property.
		/// </summary>
		internal sealed partial class ProjectMappingTablePropertyHandler : DslModeling::DomainPropertyValueHandler<DataContractModel, global::System.String>
		{
			private ProjectMappingTablePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the DataContractModel.ProjectMappingTable domain property value handler.
			/// </summary>
			public static readonly ProjectMappingTablePropertyHandler Instance = new ProjectMappingTablePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the DataContractModel.ProjectMappingTable domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return ProjectMappingTableDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(DataContractModel element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.projectMappingTablePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(DataContractModel element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.projectMappingTablePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region Name domain property code
		
		/// <summary>
		/// Name domain property Id.
		/// </summary>
		public static readonly global::System.Guid NameDomainPropertyId = new global::System.Guid(0xfc50fce3, 0xbc71, 0x4dcc, 0xa7, 0x3f, 0x5d, 0x31, 0x08, 0x64, 0x7c, 0x57);
		
		/// <summary>
		/// Storage for Name
		/// </summary>
		private global::System.String namePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Name domain property.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel.Name
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel/Name.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel/Name.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel/Name.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[global::System.ComponentModel.Browsable(false)]
		[DslModeling::ElementName]
		[DslModeling::DomainObjectId("fc50fce3-bc71-4dcc-a73f-5d3108647c57")]
		public global::System.String Name
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return namePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				NamePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the DataContractModel.Name domain property.
		/// </summary>
		internal sealed partial class NamePropertyHandler : DslModeling::DomainPropertyValueHandler<DataContractModel, global::System.String>
		{
			private NamePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the DataContractModel.Name domain property value handler.
			/// </summary>
			public static readonly NamePropertyHandler Instance = new NamePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the DataContractModel.Name domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return NameDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(DataContractModel element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.namePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(DataContractModel element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.namePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region Namespace domain property code
		
		/// <summary>
		/// Namespace domain property Id.
		/// </summary>
		public static readonly global::System.Guid NamespaceDomainPropertyId = new global::System.Guid(0x6a95c677, 0x4a65, 0x4b89, 0xb3, 0xb8, 0x43, 0x97, 0x3b, 0x86, 0x18, 0x3e);
		
		/// <summary>
		/// Storage for Namespace
		/// </summary>
		private global::System.String namespacePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Namespace domain property.
		/// This value represents the default XML namespace that will be applied to each
		/// shape added to the design surface.
		/// </summary>
		[System.ComponentModel.TypeConverter(typeof(Microsoft.Practices.Modeling.Dsl.Integration.Design.XmlNamespaceStringConverter))]
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel/Namespace.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel/Namespace.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel/Namespace.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("6a95c677-4a65-4b89-b3b8-43973b86183e")]
		public global::System.String Namespace
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return namespacePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				NamespacePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the DataContractModel.Namespace domain property.
		/// </summary>
		internal sealed partial class NamespacePropertyHandler : DslModeling::DomainPropertyValueHandler<DataContractModel, global::System.String>
		{
			private NamespacePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the DataContractModel.Namespace domain property value handler.
			/// </summary>
			public static readonly NamespacePropertyHandler Instance = new NamespacePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the DataContractModel.Namespace domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return NamespaceDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(DataContractModel element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.namespacePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(DataContractModel element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.namespacePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region Contracts opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Contracts.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.DataContracts.DataContractModelHasContracts.DataContractModel
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Contract> Contracts
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Contract>, Contract>(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractModelHasContracts.DataContractModelDomainRoleId);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Microsoft.Practices.ServiceFactory.DataContracts.Contract.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Microsoft.Practices.ServiceFactory.DataContracts.Contract sourceContract1 = sourceElement as global::Microsoft.Practices.ServiceFactory.DataContracts.Contract;
			if (sourceContract1 != null)
			{
				// Create link for path DataContractModelHasContracts.Contracts
				this.Contracts.Add(sourceContract1);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Microsoft.Practices.ServiceFactory.DataContracts.Contract sourceContract1 = sourceElement as global::Microsoft.Practices.ServiceFactory.DataContracts.Contract;
			if (sourceContract1 != null)
			{
				// Delete link for path DataContractModelHasContracts.Contracts
				
				foreach (DslModeling::ElementLink link in global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractModelHasContracts.GetLinks((global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractModel)this, sourceContract1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractModelHasContracts.DataContractModelDomainRoleId, global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractModelHasContracts.ContractDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.DataContracts
{
	/// <summary>
	/// DomainClass DataContract
	/// Description for Microsoft.Practices.ServiceFactory.DataContracts.DataContract
	/// </summary>
	[Microsoft.Practices.Modeling.CodeGeneration.Metadata.ProjectMappingRoleAttribute(Microsoft.Practices.ServiceFactory.RecipeFramework.Extensions.Enums.ServiceFactoryRoleType.DataContractRole)]
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContract.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContract.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("04635e26-5a8d-4061-85d4-c04467c9bc42")]
	public partial class DataContract : DataContractBase
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// DataContract domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x04635e26, 0x5a8d, 0x4061, 0x85, 0xd4, 0xc0, 0x44, 0x67, 0xc9, 0xbc, 0x42);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public DataContract(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public DataContract(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region DataMembers opposite domain role accessor
		
		/// <summary>
		/// Gets a list of DataMembers.
		/// A reference to a data contract shape that represents this collection’s type.
		/// When this value is defined, a connector will associate the two shapes on the
		/// design surface.
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<DataMember> DataMembers
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<DataMember>, DataMember>(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractHasDataMembers.DataContractDomainRoleId);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType.DomainClassId)) 
				{
					return true;
				}
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Microsoft.Practices.ServiceFactory.DataContracts.ReferenceDataType.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType sourcePrimitiveDataType1 = sourceElement as global::Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType;
			if (sourcePrimitiveDataType1 != null)
			{
				// Create link for path DataContractHasDataMembers.DataMembers
				this.DataMembers.Add(sourcePrimitiveDataType1);

				return;
			}
				
			global::Microsoft.Practices.ServiceFactory.DataContracts.ReferenceDataType sourceReferenceDataType2 = sourceElement as global::Microsoft.Practices.ServiceFactory.DataContracts.ReferenceDataType;
			if (sourceReferenceDataType2 != null)
			{
				// Create link for path DataContractHasDataMembers.DataMembers
				this.DataMembers.Add(sourceReferenceDataType2);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType sourcePrimitiveDataType1 = sourceElement as global::Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType;
			if (sourcePrimitiveDataType1 != null)
			{
				// Delete link for path DataContractHasDataMembers.DataMembers
				
				foreach (DslModeling::ElementLink link in global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractHasDataMembers.GetLinks((global::Microsoft.Practices.ServiceFactory.DataContracts.DataContract)this, sourcePrimitiveDataType1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractHasDataMembers.DataContractDomainRoleId, global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractHasDataMembers.DataMemberDomainRoleId);
				}

				return;
			}
				
			global::Microsoft.Practices.ServiceFactory.DataContracts.ReferenceDataType sourceReferenceDataType2 = sourceElement as global::Microsoft.Practices.ServiceFactory.DataContracts.ReferenceDataType;
			if (sourceReferenceDataType2 != null)
			{
				// Delete link for path DataContractHasDataMembers.DataMembers
				
				foreach (DslModeling::ElementLink link in global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractHasDataMembers.GetLinks((global::Microsoft.Practices.ServiceFactory.DataContracts.DataContract)this, sourceReferenceDataType2))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractHasDataMembers.DataContractDomainRoleId, global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractHasDataMembers.DataMemberDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.DataContracts
{
	/// <summary>
	/// DomainClass ModelElementReference
	/// Description for
	/// Microsoft.Practices.ServiceFactory.DataContracts.ModelElementReference
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.ModelElementReference.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.ModelElementReference.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("e1747dbd-3b81-420b-957d-1b77bad6a33e")]
	public partial class ModelElementReference : DataMember
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// ModelElementReference domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0xe1747dbd, 0x3b81, 0x420b, 0x95, 0x7d, 0x1b, 0x77, 0xba, 0xd6, 0xa3, 0x3e);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public ModelElementReference(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public ModelElementReference(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region ModelElementGuid domain property code
		
		/// <summary>
		/// ModelElementGuid domain property Id.
		/// </summary>
		public static readonly global::System.Guid ModelElementGuidDomainPropertyId = new global::System.Guid(0xed001487, 0xc6e3, 0x4e6b, 0x93, 0xee, 0x73, 0x37, 0xb9, 0x02, 0x7d, 0x72);
		
		/// <summary>
		/// Storage for ModelElementGuid
		/// </summary>
		private global::System.Guid modelElementGuidPropertyStorage;
		
		/// <summary>
		/// Gets or sets the value of ModelElementGuid domain property.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.DataContracts.ModelElementReference.Model
		/// Element Guid
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.ModelElementReference/ModelElementGuid.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.ModelElementReference/ModelElementGuid.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.ModelElementReference/ModelElementGuid.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[global::System.ComponentModel.Browsable(false)]
		[global::System.ComponentModel.ReadOnly(true)]
		[DslModeling::DomainObjectId("ed001487-c6e3-4e6b-93ee-7337b9027d72")]
		internal global::System.Guid ModelElementGuid
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return modelElementGuidPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				ModelElementGuidPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the ModelElementReference.ModelElementGuid domain property.
		/// </summary>
		internal sealed partial class ModelElementGuidPropertyHandler : DslModeling::DomainPropertyValueHandler<ModelElementReference, global::System.Guid>
		{
			private ModelElementGuidPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the ModelElementReference.ModelElementGuid domain property value handler.
			/// </summary>
			public static readonly ModelElementGuidPropertyHandler Instance = new ModelElementGuidPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the ModelElementReference.ModelElementGuid domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return ModelElementGuidDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.Guid GetValue(ModelElementReference element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.modelElementGuidPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(ModelElementReference element, global::System.Guid newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.Guid oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.modelElementGuidPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region Type domain property code
		
		/// <summary>
		/// Type domain property Id.
		/// </summary>
		public static readonly global::System.Guid TypeDomainPropertyId = new global::System.Guid(0x0af438e9, 0x86ae, 0x47e3, 0x90, 0xa4, 0x75, 0xf8, 0x9b, 0xf6, 0x3a, 0x8c);
		
		/// <summary>
		/// Storage for Type
		/// </summary>
		private global::System.String typePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Type domain property.
		/// A cross-model reference to the associated data contract type.
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.ModelElementReference/Type.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.ModelElementReference/Type.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.ModelElementReference/Type.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[global::System.ComponentModel.ReadOnly(true)]
		[DslModeling::DomainObjectId("0af438e9-86ae-47e3-90a4-75f89bf63a8c")]
		public global::System.String Type
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return typePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				TypePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the ModelElementReference.Type domain property.
		/// </summary>
		internal sealed partial class TypePropertyHandler : DslModeling::DomainPropertyValueHandler<ModelElementReference, global::System.String>
		{
			private TypePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the ModelElementReference.Type domain property value handler.
			/// </summary>
			public static readonly TypePropertyHandler Instance = new TypePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the ModelElementReference.Type domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return TypeDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(ModelElementReference element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.typePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(ModelElementReference element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.typePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.DataContracts
{
	/// <summary>
	/// DomainClass PrimitiveDataType
	/// Description for
	/// Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("b9b9dbf7-eec8-4181-8a3a-81ad1e4e63bf")]
	public partial class PrimitiveDataType : DataMember
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// PrimitiveDataType domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0xb9b9dbf7, 0xeec8, 0x4181, 0x8a, 0x3a, 0x81, 0xad, 0x1e, 0x4e, 0x63, 0xbf);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public PrimitiveDataType(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public PrimitiveDataType(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region IsNullable domain property code
		
		/// <summary>
		/// IsNullable domain property Id.
		/// </summary>
		public static readonly global::System.Guid IsNullableDomainPropertyId = new global::System.Guid(0x5404b15f, 0xf07f, 0x4ae7, 0xb7, 0x01, 0x65, 0xaf, 0xf9, 0x46, 0xcd, 0x8b);
		
		/// <summary>
		/// Storage for IsNullable
		/// </summary>
		private global::System.Boolean isNullablePropertyStorage;
		
		/// <summary>
		/// Gets or sets the value of IsNullable domain property.
		/// Indicates whether or not this part can have a null value.
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType/IsNullable.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType/IsNullable.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType/IsNullable.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("5404b15f-f07f-4ae7-b701-65aff946cd8b")]
		public global::System.Boolean IsNullable
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return isNullablePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				IsNullablePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the PrimitiveDataType.IsNullable domain property.
		/// </summary>
		internal sealed partial class IsNullablePropertyHandler : DslModeling::DomainPropertyValueHandler<PrimitiveDataType, global::System.Boolean>
		{
			private IsNullablePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the PrimitiveDataType.IsNullable domain property value handler.
			/// </summary>
			public static readonly IsNullablePropertyHandler Instance = new IsNullablePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the PrimitiveDataType.IsNullable domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return IsNullableDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.Boolean GetValue(PrimitiveDataType element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.isNullablePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(PrimitiveDataType element, global::System.Boolean newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.Boolean oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.isNullablePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region Type domain property code
		
		/// <summary>
		/// Type domain property Id.
		/// </summary>
		public static readonly global::System.Guid TypeDomainPropertyId = new global::System.Guid(0xe7c05794, 0x884c, 0x453e, 0x95, 0xa2, 0x6a, 0x6a, 0xe5, 0xbf, 0xd0, 0x63);
		
		/// <summary>
		/// Storage for Type
		/// </summary>
		private global::System.String typePropertyStorage = "System.String";
		
		/// <summary>
		/// Gets or sets the value of Type domain property.
		/// A .NET primitive type.
		/// </summary>
		[System.ComponentModel.Editor(typeof(Microsoft.Practices.ServiceFactory.RecipeFramework.Extensions.Editors.TypeBrowser.FilteredTypeBrowser), typeof(System.Drawing.Design.UITypeEditor))]
		[System.ComponentModel.TypeConverterAttribute(typeof(System.ComponentModel.TypeConverter))]
		[System.Workflow.ComponentModel.Design.TypeFilterProvider(typeof(Microsoft.Practices.ServiceFactory.RecipeFramework.Extensions.Editors.TypeBrowser.PublicPrimitiveTypeFilter))]
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType/Type.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType/Type.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType/Type.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[global::System.ComponentModel.DefaultValue("System.String")]
		[DslModeling::DomainObjectId("e7c05794-884c-453e-95a2-6a6ae5bfd063")]
		public global::System.String Type
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return typePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				TypePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the PrimitiveDataType.Type domain property.
		/// </summary>
		internal sealed partial class TypePropertyHandler : DslModeling::DomainPropertyValueHandler<PrimitiveDataType, global::System.String>
		{
			private TypePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the PrimitiveDataType.Type domain property value handler.
			/// </summary>
			public static readonly TypePropertyHandler Instance = new TypePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the PrimitiveDataType.Type domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return TypeDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(PrimitiveDataType element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.typePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(PrimitiveDataType element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.typePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.DataContracts
{
	/// <summary>
	/// DomainClass FaultContract
	/// Description for Microsoft.Practices.ServiceFactory.DataContracts.FaultContract
	/// </summary>
	[Microsoft.Practices.Modeling.CodeGeneration.Metadata.ProjectMappingRoleAttribute(Microsoft.Practices.ServiceFactory.RecipeFramework.Extensions.Enums.ServiceFactoryRoleType.FaultContractRole)]
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.FaultContract.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.FaultContract.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("4cac4673-ab9f-43b8-b2e0-122262ec97c8")]
	public partial class FaultContract : Contract
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// FaultContract domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x4cac4673, 0xab9f, 0x43b8, 0xb2, 0xe0, 0x12, 0x22, 0x62, 0xec, 0x97, 0xc8);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public FaultContract(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public FaultContract(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region DataMembers opposite domain role accessor
		
		/// <summary>
		/// Gets a list of DataMembers.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.DataContracts.FaultContractHasDataMembers.FaultContract
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<DataMember> DataMembers
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<DataMember>, DataMember>(global::Microsoft.Practices.ServiceFactory.DataContracts.FaultContractHasDataMembers.FaultContractDomainRoleId);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType sourcePrimitiveDataType1 = sourceElement as global::Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType;
			if (sourcePrimitiveDataType1 != null)
			{
				// Create link for path FaultContractHasDataMembers.DataMembers
				this.DataMembers.Add(sourcePrimitiveDataType1);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType sourcePrimitiveDataType1 = sourceElement as global::Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataType;
			if (sourcePrimitiveDataType1 != null)
			{
				// Delete link for path FaultContractHasDataMembers.DataMembers
				
				foreach (DslModeling::ElementLink link in global::Microsoft.Practices.ServiceFactory.DataContracts.FaultContractHasDataMembers.GetLinks((global::Microsoft.Practices.ServiceFactory.DataContracts.FaultContract)this, sourcePrimitiveDataType1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Microsoft.Practices.ServiceFactory.DataContracts.FaultContractHasDataMembers.FaultContractDomainRoleId, global::Microsoft.Practices.ServiceFactory.DataContracts.FaultContractHasDataMembers.DataMemberDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.DataContracts
{
	/// <summary>
	/// DomainClass DataContractBase
	/// Description for
	/// Microsoft.Practices.ServiceFactory.DataContracts.DataContractBase
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractBase.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractBase.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("c932bc1a-8a9b-4fd8-b95e-b307951d8cb4")]
	public abstract partial class DataContractBase : Contract
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// DataContractBase domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0xc932bc1a, 0x8a9b, 0x4fd8, 0xb9, 0x5e, 0xb3, 0x07, 0x95, 0x1d, 0x8c, 0xb4);
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		protected DataContractBase(DslModeling::Partition partition, DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Contracts opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Contracts.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.DataContracts.DataContractBaseCanBeContainedOnContracts.DataContractBase
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Contract> Contracts
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Contract>, Contract>(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractBaseCanBeContainedOnContracts.DataContractBaseDomainRoleId);
			}
		}
		#endregion
		#region DataContractCollections opposite domain role accessor
		
		/// <summary>
		/// Gets a list of DataContractCollections.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.DataContracts.DataContractBaseIsBeingReferenceOnDataContractCollections.DataContractBase
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<DataContractCollection> DataContractCollections
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<DataContractCollection>, DataContractCollection>(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractBaseIsBeingReferenceOnDataContractCollections.DataContractBaseDomainRoleId);
			}
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.DataContracts
{
	/// <summary>
	/// DomainClass DataContractCollection
	/// Description for
	/// Microsoft.Practices.ServiceFactory.DataContracts.DataContractCollection
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractCollection.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractCollection.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("03aed388-b285-423b-a2c0-557118ae35cb")]
	public partial class DataContractCollection : DataContractCollectionBase
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// DataContractCollection domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x03aed388, 0xb285, 0x423b, 0xa2, 0xc0, 0x55, 0x71, 0x18, 0xae, 0x35, 0xcb);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public DataContractCollection(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public DataContractCollection(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region DataContract opposite domain role accessor
		/// <summary>
		/// Gets or sets DataContract.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.DataContracts.DataContractBaseIsBeingReferenceOnDataContractCollections.DataContractCollection
		/// </summary>
		public virtual DataContractBase DataContract
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractBaseIsBeingReferenceOnDataContractCollections.DataContractCollectionDomainRoleId) as DataContractBase;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractBaseIsBeingReferenceOnDataContractCollections.DataContractCollectionDomainRoleId, value);
			}
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.DataContracts
{
	/// <summary>
	/// DomainClass DataContractEnum
	/// Description for
	/// Microsoft.Practices.ServiceFactory.DataContracts.DataContractEnum
	/// </summary>
	[Microsoft.Practices.Modeling.CodeGeneration.Metadata.ProjectMappingRoleAttribute(Microsoft.Practices.ServiceFactory.RecipeFramework.Extensions.Enums.ServiceFactoryRoleType.DataContractRole)]
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractEnum.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractEnum.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("1223d55d-832f-43ca-80c0-f3ca789ede57")]
	public partial class DataContractEnum : DataContractBase
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// DataContractEnum domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x1223d55d, 0x832f, 0x43ca, 0x80, 0xc0, 0xf3, 0xca, 0x78, 0x9e, 0xde, 0x57);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public DataContractEnum(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public DataContractEnum(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region EnumNamedValues opposite domain role accessor
		
		/// <summary>
		/// Gets a list of EnumNamedValues.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.DataContracts.DataContractEnumHasEnumNamedValues.DataContractEnum
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<EnumNamedValue> EnumNamedValues
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<EnumNamedValue>, EnumNamedValue>(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractEnumHasEnumNamedValues.DataContractEnumDomainRoleId);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Microsoft.Practices.ServiceFactory.DataContracts.EnumNamedValue.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Microsoft.Practices.ServiceFactory.DataContracts.EnumNamedValue sourceEnumNamedValue1 = sourceElement as global::Microsoft.Practices.ServiceFactory.DataContracts.EnumNamedValue;
			if (sourceEnumNamedValue1 != null)
			{
				// Create link for path DataContractEnumHasEnumNamedValues.EnumNamedValues
				this.EnumNamedValues.Add(sourceEnumNamedValue1);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Microsoft.Practices.ServiceFactory.DataContracts.EnumNamedValue sourceEnumNamedValue1 = sourceElement as global::Microsoft.Practices.ServiceFactory.DataContracts.EnumNamedValue;
			if (sourceEnumNamedValue1 != null)
			{
				// Delete link for path DataContractEnumHasEnumNamedValues.EnumNamedValues
				
				foreach (DslModeling::ElementLink link in global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractEnumHasEnumNamedValues.GetLinks((global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractEnum)this, sourceEnumNamedValue1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractEnumHasEnumNamedValues.DataContractEnumDomainRoleId, global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractEnumHasEnumNamedValues.EnumNamedValueDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.DataContracts
{
	/// <summary>
	/// DomainClass EnumNamedValue
	/// Description for Microsoft.Practices.ServiceFactory.DataContracts.EnumNamedValue
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.EnumNamedValue.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.EnumNamedValue.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel))]
	[global::System.CLSCompliant(true)]
	[global::System.Diagnostics.DebuggerDisplay("{GetType().Name,nq} (Name = {namePropertyStorage})")]
	[DslModeling::DomainObjectId("57b615db-0b54-476b-a04a-d4dec6666e94")]
	public partial class EnumNamedValue : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// EnumNamedValue domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x57b615db, 0x0b54, 0x476b, 0xa0, 0x4a, 0xd4, 0xde, 0xc6, 0x66, 0x6e, 0x94);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public EnumNamedValue(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public EnumNamedValue(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Value domain property code
		
		/// <summary>
		/// Value domain property Id.
		/// </summary>
		public static readonly global::System.Guid ValueDomainPropertyId = new global::System.Guid(0x9f96c3f4, 0x3f45, 0x4c67, 0x97, 0x59, 0xc6, 0x7d, 0xba, 0x91, 0xff, 0x01);
		
		/// <summary>
		/// Storage for Value
		/// </summary>
		private global::System.String valuePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Value domain property.
		/// The value of the enum value.
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.EnumNamedValue/Value.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.EnumNamedValue/Value.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.EnumNamedValue/Value.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("9f96c3f4-3f45-4c67-9759-c67dba91ff01")]
		public global::System.String Value
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return valuePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				ValuePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the EnumNamedValue.Value domain property.
		/// </summary>
		internal sealed partial class ValuePropertyHandler : DslModeling::DomainPropertyValueHandler<EnumNamedValue, global::System.String>
		{
			private ValuePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the EnumNamedValue.Value domain property value handler.
			/// </summary>
			public static readonly ValuePropertyHandler Instance = new ValuePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the EnumNamedValue.Value domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return ValueDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(EnumNamedValue element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.valuePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(EnumNamedValue element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.valuePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region Name domain property code
		
		/// <summary>
		/// Name domain property Id.
		/// </summary>
		public static readonly global::System.Guid NameDomainPropertyId = new global::System.Guid(0xfe3492af, 0xd412, 0x4641, 0xb2, 0xf0, 0x27, 0xcd, 0xea, 0xc1, 0x32, 0xd3);
		
		/// <summary>
		/// Storage for Name
		/// </summary>
		private global::System.String namePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Name domain property.
		/// The name of the enum value.
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.EnumNamedValue/Name.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.EnumNamedValue/Name.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.EnumNamedValue/Name.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslModeling::ElementName]
		[DslModeling::DomainObjectId("fe3492af-d412-4641-b2f0-27cdeac132d3")]
		public global::System.String Name
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return namePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				NamePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the EnumNamedValue.Name domain property.
		/// </summary>
		internal sealed partial class NamePropertyHandler : DslModeling::DomainPropertyValueHandler<EnumNamedValue, global::System.String>
		{
			private NamePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the EnumNamedValue.Name domain property value handler.
			/// </summary>
			public static readonly NamePropertyHandler Instance = new NamePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the EnumNamedValue.Name domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return NameDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(EnumNamedValue element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.namePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(EnumNamedValue element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.namePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region DataContractEnum opposite domain role accessor
		/// <summary>
		/// Gets or sets DataContractEnum.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.DataContracts.DataContractEnumHasEnumNamedValues.EnumNamedValue
		/// </summary>
		public virtual DataContractEnum DataContractEnum
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractEnumHasEnumNamedValues.EnumNamedValueDomainRoleId) as DataContractEnum;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractEnumHasEnumNamedValues.EnumNamedValueDomainRoleId, value);
			}
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.DataContracts
{
	/// <summary>
	/// DomainClass ExtensibleModelElement
	/// Description for
	/// Microsoft.Practices.ServiceFactory.DataContracts.ExtensibleModelElement
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.ExtensibleModelElement.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.ExtensibleModelElement.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel))]
	[global::System.CLSCompliant(true)]
	[global::System.Diagnostics.DebuggerDisplay("{GetType().Name,nq} (Name = {namePropertyStorage})")]
	[DslModeling::DomainObjectId("b29bc5c1-1e94-443e-8962-782c95966279")]
	public abstract partial class ExtensibleModelElement : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// ExtensibleModelElement domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0xb29bc5c1, 0x1e94, 0x443e, 0x89, 0x62, 0x78, 0x2c, 0x95, 0x96, 0x62, 0x79);
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		protected ExtensibleModelElement(DslModeling::Partition partition, DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region ObjectExtenderContainer domain property code
		
		/// <summary>
		/// ObjectExtenderContainer domain property Id.
		/// </summary>
		public static readonly global::System.Guid ObjectExtenderContainerDomainPropertyId = new global::System.Guid(0x3e1aec86, 0xc60b, 0x4dc1, 0xa3, 0x0c, 0xc9, 0x34, 0x1b, 0x31, 0xe1, 0x31);
		
		/// <summary>
		/// Storage for ObjectExtenderContainer
		/// </summary>
		private global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.ObjectExtenderContainer objectExtenderContainerPropertyStorage;
		
		/// <summary>
		/// Gets or sets the value of ObjectExtenderContainer domain property.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.DataContracts.ExtensibleModelElement.Object
		/// Extender Container
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.ExtensibleModelElement/ObjectExtenderContainer.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.ExtensibleModelElement/ObjectExtenderContainer.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.ExtensibleModelElement/ObjectExtenderContainer.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[global::System.ComponentModel.Browsable(false)]
		[DslModeling::DomainObjectId("3e1aec86-c60b-4dc1-a30c-c9341b31e131")]
		public global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.ObjectExtenderContainer ObjectExtenderContainer
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return objectExtenderContainerPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				ObjectExtenderContainerPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the ExtensibleModelElement.ObjectExtenderContainer domain property.
		/// </summary>
		internal sealed partial class ObjectExtenderContainerPropertyHandler : DslModeling::DomainPropertyValueHandler<ExtensibleModelElement, global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.ObjectExtenderContainer>
		{
			private ObjectExtenderContainerPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the ExtensibleModelElement.ObjectExtenderContainer domain property value handler.
			/// </summary>
			public static readonly ObjectExtenderContainerPropertyHandler Instance = new ObjectExtenderContainerPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the ExtensibleModelElement.ObjectExtenderContainer domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return ObjectExtenderContainerDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.ObjectExtenderContainer GetValue(ExtensibleModelElement element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.objectExtenderContainerPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(ExtensibleModelElement element, global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.ObjectExtenderContainer newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::Microsoft.Practices.Modeling.ExtensionProvider.Extension.ObjectExtenderContainer oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.objectExtenderContainerPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region Name domain property code
		
		/// <summary>
		/// Name domain property Id.
		/// </summary>
		public static readonly global::System.Guid NameDomainPropertyId = new global::System.Guid(0xed45a70b, 0x11f9, 0x4e36, 0xa9, 0x5c, 0x70, 0xd3, 0x78, 0xe7, 0xc4, 0x2d);
		
		/// <summary>
		/// Storage for Name
		/// </summary>
		private global::System.String namePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Name domain property.
		/// The name of this model element.
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.ExtensibleModelElement/Name.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.ExtensibleModelElement/Name.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.ExtensibleModelElement/Name.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslModeling::ElementName]
		[DslModeling::DomainObjectId("ed45a70b-11f9-4e36-a95c-70d378e7c42d")]
		public global::System.String Name
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return namePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				NamePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the ExtensibleModelElement.Name domain property.
		/// </summary>
		internal sealed partial class NamePropertyHandler : DslModeling::DomainPropertyValueHandler<ExtensibleModelElement, global::System.String>
		{
			private NamePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the ExtensibleModelElement.Name domain property value handler.
			/// </summary>
			public static readonly NamePropertyHandler Instance = new NamePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the ExtensibleModelElement.Name domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return NameDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(ExtensibleModelElement element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.namePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(ExtensibleModelElement element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.namePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region Remarks domain property code
		
		/// <summary>
		/// Remarks domain property Id.
		/// </summary>
		public static readonly global::System.Guid RemarksDomainPropertyId = new global::System.Guid(0xd8b6637c, 0x6207, 0x4e13, 0xae, 0xb6, 0xb0, 0x84, 0xf1, 0xee, 0xcd, 0xb2);
		
		/// <summary>
		/// Storage for Remarks
		/// </summary>
		private global::System.String remarksPropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Remarks domain property.
		/// Provides additional documentation information to this element. Its content will
		/// be added as a <remarks> element to the generated code.
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.ExtensibleModelElement/Remarks.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.ExtensibleModelElement/Remarks.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.ExtensibleModelElement/Remarks.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("d8b6637c-6207-4e13-aeb6-b084f1eecdb2")]
		public global::System.String Remarks
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return remarksPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				RemarksPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the ExtensibleModelElement.Remarks domain property.
		/// </summary>
		internal sealed partial class RemarksPropertyHandler : DslModeling::DomainPropertyValueHandler<ExtensibleModelElement, global::System.String>
		{
			private RemarksPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the ExtensibleModelElement.Remarks domain property value handler.
			/// </summary>
			public static readonly RemarksPropertyHandler Instance = new RemarksPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the ExtensibleModelElement.Remarks domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return RemarksDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(ExtensibleModelElement element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.remarksPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(ExtensibleModelElement element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.remarksPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.DataContracts
{
	/// <summary>
	/// DomainClass DataMember
	/// Description for Microsoft.Practices.ServiceFactory.DataContracts.DataMember
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.DataMember.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.DataMember.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("98d1cea1-fbc0-4b05-93c6-76a3e88889fa")]
	public abstract partial class DataMember : ExtensibleModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// DataMember domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x98d1cea1, 0xfbc0, 0x4b05, 0x93, 0xc6, 0x76, 0xa3, 0xe8, 0x88, 0x89, 0xfa);
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		protected DataMember(DslModeling::Partition partition, DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region IsDataMember domain property code
		
		/// <summary>
		/// IsDataMember domain property Id.
		/// </summary>
		public static readonly global::System.Guid IsDataMemberDomainPropertyId = new global::System.Guid(0x661025df, 0x2833, 0x47f0, 0x8c, 0x1b, 0x69, 0x4e, 0xfc, 0x4c, 0x12, 0x18);
		
		/// <summary>
		/// Storage for IsDataMember
		/// </summary>
		private global::System.Boolean isDataMemberPropertyStorage = true;
		
		/// <summary>
		/// Gets or sets the value of IsDataMember domain property.
		/// The default value of true ensures this member is serialized into messages.
		/// Otherwise, it will not be serialized.
		/// </summary>
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.DataMember/IsDataMember.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.DataMember/IsDataMember.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.DataMember/IsDataMember.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[global::System.ComponentModel.DefaultValue(true)]
		[DslModeling::DomainObjectId("661025df-2833-47f0-8c1b-694efc4c1218")]
		public global::System.Boolean IsDataMember
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return isDataMemberPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				IsDataMemberPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the DataMember.IsDataMember domain property.
		/// </summary>
		internal sealed partial class IsDataMemberPropertyHandler : DslModeling::DomainPropertyValueHandler<DataMember, global::System.Boolean>
		{
			private IsDataMemberPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the DataMember.IsDataMember domain property value handler.
			/// </summary>
			public static readonly IsDataMemberPropertyHandler Instance = new IsDataMemberPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the DataMember.IsDataMember domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return IsDataMemberDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.Boolean GetValue(DataMember element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.isDataMemberPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(DataMember element, global::System.Boolean newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.Boolean oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.isDataMemberPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region CollectionType domain property code
		
		/// <summary>
		/// CollectionType domain property Id.
		/// </summary>
		public static readonly global::System.Guid CollectionTypeDomainPropertyId = new global::System.Guid(0xe1f7793c, 0x31b2, 0x4b6b, 0xa6, 0x0a, 0xb9, 0xcf, 0x33, 0x79, 0xa9, 0xed);
		
		/// <summary>
		/// Storage for CollectionType
		/// </summary>
		private global::System.Type collectionTypePropertyStorage;
		
		/// <summary>
		/// Gets or sets the value of CollectionType domain property.
		/// If this member represents a collection, this value controls the type of
		/// collection. None indicates that this member is not a collection.
		/// </summary>
		[System.ComponentModel.Editor(typeof(Microsoft.Practices.ServiceFactory.DataContracts.CollectionTypesEditor), typeof(System.Drawing.Design.UITypeEditor))]
		[System.ComponentModel.TypeConverterAttribute(typeof(Microsoft.Practices.ServiceFactory.DataContracts.CollectionTypesConverter))]
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.DataMember/CollectionType.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.DataMember/CollectionType.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.DataMember/CollectionType.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("e1f7793c-31b2-4b6b-a60a-b9cf3379a9ed")]
		public global::System.Type CollectionType
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return collectionTypePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				CollectionTypePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the DataMember.CollectionType domain property.
		/// </summary>
		internal sealed partial class CollectionTypePropertyHandler : DslModeling::DomainPropertyValueHandler<DataMember, global::System.Type>
		{
			private CollectionTypePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the DataMember.CollectionType domain property value handler.
			/// </summary>
			public static readonly CollectionTypePropertyHandler Instance = new CollectionTypePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the DataMember.CollectionType domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return CollectionTypeDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.Type GetValue(DataMember element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.collectionTypePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(DataMember element, global::System.Type newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.Type oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.collectionTypePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region DataContract opposite domain role accessor
		/// <summary>
		/// Gets or sets DataContract.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.DataContracts.DataContractHasDataMembers.DataMember
		/// </summary>
		public virtual DataContract DataContract
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractHasDataMembers.DataMemberDomainRoleId) as DataContract;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractHasDataMembers.DataMemberDomainRoleId, value);
			}
		}
		#endregion
		#region FaultContract opposite domain role accessor
		/// <summary>
		/// Gets or sets FaultContract.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.DataContracts.FaultContractHasDataMembers.DataMember
		/// </summary>
		public virtual FaultContract FaultContract
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.DataContracts.FaultContractHasDataMembers.DataMemberDomainRoleId) as FaultContract;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.DataContracts.FaultContractHasDataMembers.DataMemberDomainRoleId, value);
			}
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.DataContracts
{
	/// <summary>
	/// DomainClass PrimitiveDataTypeCollection
	/// Description for
	/// Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataTypeCollection
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataTypeCollection.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataTypeCollection.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("19fca223-ff6b-4096-9d6c-2ea2db247b78")]
	public partial class PrimitiveDataTypeCollection : DataContractCollectionBase
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// PrimitiveDataTypeCollection domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x19fca223, 0xff6b, 0x4096, 0x9d, 0x6c, 0x2e, 0xa2, 0xdb, 0x24, 0x7b, 0x78);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public PrimitiveDataTypeCollection(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public PrimitiveDataTypeCollection(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region ItemType domain property code
		
		/// <summary>
		/// ItemType domain property Id.
		/// </summary>
		public static readonly global::System.Guid ItemTypeDomainPropertyId = new global::System.Guid(0x06027595, 0x4a6d, 0x4a1a, 0x96, 0x75, 0xeb, 0xe4, 0x6a, 0x1f, 0x25, 0xa8);
		
		/// <summary>
		/// Storage for ItemType
		/// </summary>
		private global::System.String itemTypePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of ItemType domain property.
		/// The .NET primitive that defines this collection’s type. 
		/// </summary>
		[System.ComponentModel.Editor(typeof(Microsoft.Practices.ServiceFactory.RecipeFramework.Extensions.Editors.TypeBrowser.FilteredTypeBrowser), typeof(System.Drawing.Design.UITypeEditor))]
		[System.ComponentModel.TypeConverterAttribute(typeof(System.ComponentModel.TypeConverter))]
		[System.Workflow.ComponentModel.Design.TypeFilterProvider(typeof(Microsoft.Practices.ServiceFactory.RecipeFramework.Extensions.Editors.TypeBrowser.PublicPrimitiveTypeFilter))]
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataTypeCollection/ItemType.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataTypeCollection/ItemType.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.PrimitiveDataTypeCollection/ItemType.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("06027595-4a6d-4a1a-9675-ebe46a1f25a8")]
		public global::System.String ItemType
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return itemTypePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				ItemTypePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the PrimitiveDataTypeCollection.ItemType domain property.
		/// </summary>
		internal sealed partial class ItemTypePropertyHandler : DslModeling::DomainPropertyValueHandler<PrimitiveDataTypeCollection, global::System.String>
		{
			private ItemTypePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the PrimitiveDataTypeCollection.ItemType domain property value handler.
			/// </summary>
			public static readonly ItemTypePropertyHandler Instance = new ItemTypePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the PrimitiveDataTypeCollection.ItemType domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return ItemTypeDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(PrimitiveDataTypeCollection element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.itemTypePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(PrimitiveDataTypeCollection element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.itemTypePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.DataContracts
{
	/// <summary>
	/// DomainClass DataContractCollectionBase
	/// Description for
	/// Microsoft.Practices.ServiceFactory.DataContracts.DataContractCollectionBase
	/// </summary>
	[Microsoft.Practices.Modeling.CodeGeneration.Metadata.ProjectMappingRoleAttribute(Microsoft.Practices.ServiceFactory.RecipeFramework.Extensions.Enums.ServiceFactoryRoleType.DataContractRole)]
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractCollectionBase.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.DataContractCollectionBase.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("87149ac1-6fed-4095-9ced-8c54a8d94c6d")]
	public abstract partial class DataContractCollectionBase : DataContractBase
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// DataContractCollectionBase domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x87149ac1, 0x6fed, 0x4095, 0x9c, 0xed, 0x8c, 0x54, 0xa8, 0xd9, 0x4c, 0x6d);
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		protected DataContractCollectionBase(DslModeling::Partition partition, DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.DataContracts
{
	/// <summary>
	/// DomainClass Contract
	/// Description for Microsoft.Practices.ServiceFactory.DataContracts.Contract
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.Contract.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.Contract.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("8c9f551e-afb1-4c86-bf9f-be3341429813")]
	public abstract partial class Contract : ExtensibleModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// Contract domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x8c9f551e, 0xafb1, 0x4c86, 0xbf, 0x9f, 0xbe, 0x33, 0x41, 0x42, 0x98, 0x13);
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		protected Contract(DslModeling::Partition partition, DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Namespace domain property code
		
		/// <summary>
		/// Namespace domain property Id.
		/// </summary>
		public static readonly global::System.Guid NamespaceDomainPropertyId = new global::System.Guid(0xe79fac2e, 0x3798, 0x467c, 0xb8, 0x58, 0x2d, 0xbc, 0x0e, 0x6f, 0x68, 0xc7);
		
		/// <summary>
		/// Storage for Namespace
		/// </summary>
		private global::System.String namespacePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Namespace domain property.
		/// The XML namespace of this data/fault contract.
		/// </summary>
		[System.ComponentModel.TypeConverter(typeof(Microsoft.Practices.Modeling.Dsl.Integration.Design.XmlNamespaceStringConverter))]
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.Contract/Namespace.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.Contract/Namespace.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.Contract/Namespace.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("e79fac2e-3798-467c-b858-2dbc0e6f68c7")]
		public global::System.String Namespace
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return namespacePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				NamespacePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the Contract.Namespace domain property.
		/// </summary>
		internal sealed partial class NamespacePropertyHandler : DslModeling::DomainPropertyValueHandler<Contract, global::System.String>
		{
			private NamespacePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the Contract.Namespace domain property value handler.
			/// </summary>
			public static readonly NamespacePropertyHandler Instance = new NamespacePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the Contract.Namespace domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return NamespaceDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(Contract element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.namespacePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(Contract element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.namespacePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region DataContractModel opposite domain role accessor
		/// <summary>
		/// Gets or sets DataContractModel.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.DataContracts.DataContractModelHasContracts.Contract
		/// </summary>
		public virtual DataContractModel DataContractModel
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractModelHasContracts.ContractDomainRoleId) as DataContractModel;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractModelHasContracts.ContractDomainRoleId, value);
			}
		}
		#endregion
		#region DataContractElements opposite domain role accessor
		
		/// <summary>
		/// Gets a list of DataContractElements.
		/// Description for
		/// Microsoft.Practices.ServiceFactory.DataContracts.DataContractBaseCanBeContainedOnContracts.Contract
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<DataContractBase> DataContractElements
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<DataContractBase>, DataContractBase>(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractBaseCanBeContainedOnContracts.ContractDomainRoleId);
			}
		}
		#endregion
	}
}
namespace Microsoft.Practices.ServiceFactory.DataContracts
{
	/// <summary>
	/// DomainClass ReferenceDataType
	/// Description for
	/// Microsoft.Practices.ServiceFactory.DataContracts.ReferenceDataType
	/// </summary>
	[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.ReferenceDataType.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.ReferenceDataType.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("5fc92e8f-fd51-439c-ba82-561f865a1c18")]
	public partial class ReferenceDataType : DataMember
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// ReferenceDataType domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x5fc92e8f, 0xfd51, 0x439c, 0xba, 0x82, 0x56, 0x1f, 0x86, 0x5a, 0x1c, 0x18);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public ReferenceDataType(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public ReferenceDataType(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Type domain property code
		
		/// <summary>
		/// Type domain property Id.
		/// </summary>
		public static readonly global::System.Guid TypeDomainPropertyId = new global::System.Guid(0x7f9c814c, 0xdafe, 0x4708, 0xb5, 0x22, 0x94, 0x43, 0x5a, 0x71, 0xb3, 0x3f);
		
		/// <summary>
		/// Storage for Type
		/// </summary>
		private global::Microsoft.VisualStudio.Modeling.Integration.ModelBusReference typePropertyStorage;
		
		/// <summary>
		/// Gets or sets the value of Type domain property.
		/// A cross-model reference to the associated data contract type on the data
		/// contract model.
		/// </summary>
		[System.ComponentModel.Editor(typeof(Microsoft.VisualStudio.Modeling.Integration.Picker.ModelElementReferenceEditor), typeof(System.Drawing.Design.UITypeEditor))]
		[System.ComponentModel.TypeConverter(typeof(Microsoft.VisualStudio.Modeling.Integration.ModelBusReferenceTypeConverter))]
		[Microsoft.VisualStudio.Modeling.Integration.Picker.SupplyFileBasedBrowserConfiguration("Please choose a DataContract file",  "DataContract files|*.datacontract")]
		[Microsoft.VisualStudio.Modeling.Integration.Picker.ApplyElementTypeLimitations(typeof(Microsoft.Practices.ServiceFactory.DataContracts.DataContract), typeof(Microsoft.Practices.ServiceFactory.DataContracts.DataContractEnum))]
		[System.CLSCompliant(false)]
		[DslDesign::DisplayNameResource("Microsoft.Practices.ServiceFactory.DataContracts.ReferenceDataType/Type.DisplayName", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::CategoryResource("Microsoft.Practices.ServiceFactory.DataContracts.ReferenceDataType/Type.Category", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Microsoft.Practices.ServiceFactory.DataContracts.ReferenceDataType/Type.Description", typeof(global::Microsoft.Practices.ServiceFactory.DataContracts.DataContractDslDomainModel), "Microsoft.Practices.ServiceFactory.DataContracts.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("7f9c814c-dafe-4708-b522-94435a71b33f")]
		public global::Microsoft.VisualStudio.Modeling.Integration.ModelBusReference Type
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return typePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				TypePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the ReferenceDataType.Type domain property.
		/// </summary>
		internal sealed partial class TypePropertyHandler : DslModeling::DomainPropertyValueHandler<ReferenceDataType, global::Microsoft.VisualStudio.Modeling.Integration.ModelBusReference>
		{
			private TypePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the ReferenceDataType.Type domain property value handler.
			/// </summary>
			public static readonly TypePropertyHandler Instance = new TypePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the ReferenceDataType.Type domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return TypeDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::Microsoft.VisualStudio.Modeling.Integration.ModelBusReference GetValue(ReferenceDataType element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.typePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(ReferenceDataType element, global::Microsoft.VisualStudio.Modeling.Integration.ModelBusReference newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::Microsoft.VisualStudio.Modeling.Integration.ModelBusReference oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.typePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
	}
}
