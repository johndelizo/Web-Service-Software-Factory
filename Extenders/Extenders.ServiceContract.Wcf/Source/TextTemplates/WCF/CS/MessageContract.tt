<#@ Template Language="C#" Inherits="Microsoft.Practices.Modeling.CodeGeneration.Strategies.TextTemplating.ModelingTextTransformation" #>
<#@ Import Namespace="System.Text" #>
<#@ Import Namespace="System.Globalization" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="System.Xml.Serialization" #>
<#@ Import Namespace="System.Runtime.Serialization" #>
<#@ Import Namespace="Microsoft.Practices.ServiceFactory.ServiceContracts" #>
<#@ Import Namespace="Microsoft.Practices.ServiceFactory.DataContracts" #>
<#@ Import Namespace="Microsoft.Practices.ServiceFactory.Extenders.DataContract.Wcf" #>
<#@ Import Namespace="Microsoft.VisualStudio.Modeling" #>
<#@ Import Namespace="Microsoft.VisualStudio.Modeling.Integration" #>

<#@ Import Namespace="Microsoft.Practices.ServiceFactory.Description" #>
<#@ Assembly Name="Microsoft.Practices.ServiceFactory.DataContracts.Dsl" #>
<#@ Assembly Name="Microsoft.Practices.ServiceFactory.Extenders.DataContract.Wcf" #>
<#@ Assembly Name="System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ Assembly Name="Microsoft.Practices.ServiceFactory.Description" #>
<#@ ModelInjector processor="ModelInjectorDirectiveProcessor" #>
<#@ include file="Lib\TextTemplates\WCF\CS\ServiceContractWcfCommon.tt" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using WCF = global::System.ServiceModel;

namespace <#=CurrentExtender.ArtifactLink.Namespace#>
{
	/// <summary>
	/// Service Contract Class - <#= CurrentElement.Name #>
	/// </summary><#=AddRemarks(CurrentElement, "\r\n\t")#>
	[WCF::MessageContract<# PrintAttributeArguments(GetMessageContractAttributeArguments(CurrentExtender.IsWrapped)); #>]<#=ResolveXmlSerializerFormatAttribute()#> 
	public partial class <#= CurrentElement.Name #>
	{
	<# foreach (MessagePart member in CurrentElement.MessageParts) 
	   {
	#>	private <#= ResolveMessagePartType(member) #> <#= Utility.ToCamelCase(member.Name) #>;
	 <#}
	 
	foreach (MessagePart member in CurrentElement.MessageParts) 
	{
		string memberName = Utility.ToCamelCase(member.Name);
		string memberType = ResolveMessagePartType(member);		
		#>
		
		<#=AddRemarks(member, "\r\n\t\t", true)#>[WCF::MessageBodyMember<# PrintAttributeArguments(GetMessageBodyMember(member)); /*if (member.Order >= 0) { #>(Order = <#= member.Order #>)<# } */ #>]<#=ResolveXmlElementAttribute(member)#>
		public <#= memberType #> <#= member.Name #>
		{
			get { return <#= memberName #>; }
			set { <#= memberName #> = value; }
		}
	<#}
	#>
}
}

<#+
	private const string Namespace = "Namespace";
	private const string Name = "Name";
	
	private IDictionary<string, string> GetMessageBodyMember(MessagePart part)
	{
		IDictionary<string, string> args = new Dictionary<string, string>();
		
		if (part is DataContractMessagePart) 
		{
			WCFDataContractMessagePart wfcDataCont = GetObjectExtender<WCFDataContractMessagePart>(part);
			
			if(wfcDataCont != null)
			{
				if(!string.IsNullOrEmpty(wfcDataCont.Namespace))
				{
					args.Add(Namespace, string.Format("\"{0}\"", wfcDataCont.Namespace));
				}
				
				if (!string.IsNullOrEmpty(part.Name))
				{
					args.Add(Name, string.Format("\"{0}\"", part.Name));
				}
			}
		}
		else if (part is PrimitiveMessagePart)
		{
			WCFPrimitiveMessagePart wfcPrim = GetObjectExtender<WCFPrimitiveMessagePart>(part);
			
			if(wfcPrim != null)
			{
				if(!string.IsNullOrEmpty(wfcPrim.Namespace))
				{
					args.Add(Namespace, string.Format("\"{0}\"", wfcPrim.Namespace));
				}
				
				if (!string.IsNullOrEmpty(part.Name))
				{
					args.Add(Name, string.Format("\"{0}\"", part.Name));
				}
			}
		}
		
		return args;
	}	

    private string ResolveMessagePartType(MessagePart part) 
    {
		if (part is DataContractMessagePart) 
		{
			DataContractMessagePart dcMessagePart = (DataContractMessagePart) part;			
			EnsureValidType(dcMessagePart.Type);
			return ResolveTypeAndAddProjectReference(dcMessagePart.Type);    
		}
		else if (part is PrimitiveMessagePart)
		{
			PrimitiveMessagePart primitivePart = (PrimitiveMessagePart) part;
			EnsureValidType(primitivePart.Type);
			
			if(primitivePart.IsCollection)
			{
				return Utility.GetCSharpTypeDeclaration(typeof(System.Collections.Generic.List<>), primitivePart.Type);
			}
			else
			{
				return Utility.GetCSharpTypeOutput(primitivePart.Type, primitivePart.IsNullable);
			}
		}
	
		// This would indicate that a new MessagePart was added to the ServiceContract model, but the tt doesn't
		// know how to generate it.
		throw new global::System.NotSupportedException(string.Format("Unrecognized Message Part Type: {0}", part.GetType().ToString()));
    }
	
	private void EnsureValidType(object type) 
	{
		if (type == null) 
		{
			throw new global::System.ArgumentException("Cannot generate Message Contract due to invalid type.");
		}
	}

#>